# -*- coding: UTF-8 -*-
# ------------------------------------------------------------------------------
#     Copyright (c) 2023+ TYPETR
#     Usage by MIT License
# ..............................................................................
#
#   spacer.py
#
#   TODO
#   - Auto sim spacing
#   - Sample line or buttons line for alternative spacing masters
#   - Kerning line
#   - Spacing and kerning keys
#   - Set Similarity zones
#
import sys
from math import *
from vanilla import *
from AppKit import *

from mojo.UI import OpenGlyphWindow
from mojo.roboFont import CurrentFont

# Add paths to libs in sibling repositories
PATHS = ('../TYPETR-Assistants/',)
for path in PATHS:
    if not path in sys.path:
        print('@@@ Append to sys.path', path)
        sys.path.append(path)

from assistantLib.assistantParts.baseAssistantPart import BaseAssistantPart
from assistantLib.assistantParts.data import * # Import anchors names

ARROW_KEYS = [NSUpArrowFunctionKey, NSDownArrowFunctionKey,
        NSLeftArrowFunctionKey, NSRightArrowFunctionKey, NSPageUpFunctionKey,
        NSPageDownFunctionKey, NSHomeFunctionKey, NSEndFunctionKey]

class KerningLineGlyphPosition:
    """Element that holds position and name of glyphs in the spacer/kerning line. This makes it easier 
    for mouseover to detect clicks on the line"""
    def __init__(self, glyph, x, y, w, h, k, fillColor, lineIndex, sampleKerningIndex):
        self.glyph = glyph # RGlyph object 
        self.name = glyph.name
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.k = k # Kerning with previoud glyph
        self.fillColor = fillColor
        self.lineIndex = lineIndex
        self.sampleKerningIndex = sampleKerningIndex

class AssistantPartSpacer(BaseAssistantPart):
    """The Spacer assistant part handles all margins and widths that can be automated.
    It makes guesses based on the names of glyphs, existing components, values in the MasterData
    and Erik van Blokland's Similarity.
    The assistant part gives feedback about where the automated values came from, so it's easier to debug.
    """

    KERN_LINE_LENGTH = 48 # Number of glyphs on kerning line
    KERN_SCALE = 0.12 #0.2 Scaler for glyphs on kerning line

    SPACER_FIXED_WIDTH_MARKER_COLOR = 0.5, 0.5, 0.5, 0.5
    SPACER_FIXED_MARGIN_MARKER_COLOR = 0.8, 0.2, 0.4, 0.7
    SPACER_LABEL_FONT = 'Verdana'
    SPACER_LABEL_SIZE = 14
    SPACER_MARKER_R = 32 # Radius of space marker

    SPACER_KERNING_LABEL_SIZE = 24

    SPACER_FILL_COLOR = 0.2, 0.2, 0.2, 1 # Default color
    SPACER_SELECTED_COLOR = 0.2, 0.2, 0.5, 1 # Current glyph
    SPACER_HOVER_COLOR = 1, 0, 0, 1 # Mouse goes over the element
    SPACER_LINE_BOX_COLOR = 0, 0, 0, 0.5 # Stroke color of space box

    SPACER_FILL_GLYPH_COLOR = 0, 0, 0, 0.9 # Fill color for large sample glyphs on left and right side

    def initMerzSpacer(self, container):
        """Define the Merz elements for feedback about where margins/width comes from."""

        #    K E R N I N G  L I N E
    
        #km.sampleKerningIndex: offset into the full sample, generated by KerningManager for a certain mode
        self.spacerGlyphPositions = [] # Tuples (x, y, w, h, k, glyphName) Adjusted by the line lenght, to center on current glyph.width/2
        self.selectedHoverGlyphName = None # Name of glyph that is currently hovered over in the spacing line.

        self.kerningLine = [] # List of kerned/spaced glyph image layers, also buttons
        self.kerningLineValues = [] # List of kerning value layers
        self.kerningLineNames = [] # List of glyph name layers
        self.kerningLineBoxes = [] # List of kerned glyph em-boxes
        self.kerningSelectedGlyph = None # Name of the glyph selected by the kerning editor

        # Glyphs on the side in real size. Turn the Overlay glyphs off to avoid overlapping

        self.spacerGlyphLeft = container.appendPathSublayer(
            position=(0, 0),
            fillColor=self.SPACER_FILL_COLOR,
            visible=False,
        )
        self.spacerGlyphRight = container.appendPathSublayer(
            position=(0, 0),
            fillColor=self.SPACER_FILL_COLOR,
            visible=False,
        )

        # Showing actual kerning below left and right glyph in EditorWindow
        self.spacerGlyphKerningLeft = container.appendTextLineSublayer(name="spacerGlyphKerningLeft",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKerningLeft.setHorizontalAlignment('right')
        
        self.spacerGlyphKerningRight = container.appendTextLineSublayer(name="spacerGlyphKerningRight",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKerningRight.setHorizontalAlignment('left')
        
        # Showing suggested KernNet value below left and right glyph in EditorWindow

        self.spacerGlyphKernNetLeft = container.appendTextLineSublayer(name="spacerGlyphKernNetLeft",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKernNetLeft.setHorizontalAlignment('right')
        
        self.spacerGlyphKernNetRight = container.appendTextLineSublayer(name="spacerGlyphKernNetRight",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKernNetRight.setHorizontalAlignment('left')
        

        # White rectangle as background of spacer/kerning line
        self.spacerWhiteBackground = container.appendRectangleSublayer(name="spacesWhiteBackground",
            position=(0, 0),
            size=(1, 1),
            fillColor=(1, 1, 1, 0.6), # Slightly transparant, so rest of EditorWindow can be seen through.
            visible=False,
        )
        self.spacerWhiteBackground.addScaleTransformation(self.KERN_SCALE)

        # Current line number in the kerning sample (Corresponding with the proof line numbering)
        # Also showing the number of groups and kerning pairs
        self.spacerKerningLineNumber = container.appendTextLineSublayer(name="spacerKerningLineNumber",
            position=(0, 0),
            text='X',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            fillColor=(0.4, 0.4, 0.4, 1),
            visible=False,
        )
        self.spacerKerningLineNumber.addScaleTransformation(self.KERN_SCALE)
        self.spacerKerningLineNumber.setHorizontalAlignment('left')
        
        # Glyphs cells on the spacer/kerning line

        for gIndex in range(self.KERN_LINE_LENGTH):
            # Previewing current glyphs on left/right side.        
            im = container.appendPathSublayer(
                name=f'kernedGlyph-{gIndex}',
                position=(0, 0),
                fillColor=self.SPACER_FILL_COLOR,
                visible=False,
            )
            im.addScaleTransformation(self.KERN_SCALE)
            self.kerningLine.append(im)
            
            kerningLineValue = container.appendTextLineSublayer(
                name=f'kernedValue-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Can be red (negative kerning) or green (positive kerning)
                visible=False,
            )
            kerningLineValue.addScaleTransformation(self.KERN_SCALE)
            kerningLineValue.setHorizontalAlignment('center')
            self.kerningLineValues.append(kerningLineValue)

            kerningLineBox = container.appendRectangleSublayer(
                name=f'kernedBox-{gIndex}',
                position=(0, 0),
                size=(1, 1),
                fillColor=None,
                strokeColor=self.SPACER_LINE_BOX_COLOR,
                strokeWidth=1,
                visible=False,
            )
            kerningLineBox.addScaleTransformation(self.KERN_SCALE)
            self.kerningLineBoxes.append(kerningLineBox)

            kerningLineName = container.appendTextLineSublayer(
                name=f'kernedName-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Default line glyph color
                visible=False,
            )
            kerningLineName.addScaleTransformation(self.KERN_SCALE)
            kerningLineName.setHorizontalAlignment('center')
            self.kerningLineNames.append(kerningLineName)

        # Full size in editor

        self.kerningSelectedGlyphMarker = container.appendRectangleSublayer(
            name='kerningSelectedGlyphMarker',
            position=(0, 0),
            size=(1, 20),
            fillColor=(1, 0, 0, 1),
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.kerningSelectedGlyphMarker.addScaleTransformation(self.KERN_SCALE)

        self.kerning1Value = container.appendTextLineSublayer(
            name="kerning1Value",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning1Value.setHorizontalAlignment('center')
        self.kerning2Value = container.appendTextLineSublayer(
            name="kerning2Value",
            position=(0, 0),
            text='xxx\nxxx',
            font='Courier',
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning2Value.setHorizontalAlignment('center')

        self.kerningCursorBox = container.appendTextLineSublayer(
            name="kerningCursorBox",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=14,
            fillColor=(0.6, 0.6, 0.6, 1),
            visible=False,
        )


        #   S P A C I N G  M A R K E R S

        self.fixedSpaceMarkerLeft = container.appendOvalSublayer(name="spaceMarkerLeft",
            position=(-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
        )
        self.leftSpaceSourceLabel = container.appendTextLineSublayer(name="leftSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.leftSpaceSourceLabel.setHorizontalAlignment('right')
        
        self.fixedSpaceMarkerRight = container.appendOvalSublayer(name="spaceMarkerRight",
            position=(1000-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.rightSpaceSourceLabel = container.appendTextLineSublayer(name="rightSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.rightSpaceSourceLabel.setHorizontalAlignment('left')

    def updateMerzSpacer(self, info):
        """Update the spacing/kerning sample line"""
        c = self.getController()
        g = info['glyph']
        if g is None:
            return 
        if c.w.showSpacingSampleLine.get():
            self.updateMerzSpacerKerningLine(g)
        else:
            self.hideMerzSpacerKerningLine()
            g.changed()

    def hideMerzSpacerKerningLine(self):
        for kerningGlyphLayer in self.kerningLine:
            kerningGlyphLayer.setVisible(False)
        for kerningNameLayer in self.kerningLineNames:
            kerningNameLayer.setVisible(False)
        self.spacerWhiteBackground.setVisible(False)
        self.spacerKerningLineNumber.setVisible(False)

    def updateMerzSpacerKerningLine(self, g):
        """Update the spacing/kerning/sample line for the current glyphs and its settings."""
        c = self.getController()
        f = g.font

        h = f.info.unitsPerEm
        m = h/5 # Margin around white rectangle.
        x = 0 # Adjusted from the previous line calculation
        y = f.info.descender/self.KERN_SCALE - 1.5*m/self.KERN_SCALE
        k = None
        dw = f.info.unitsPerEm/5 # Extra width to zero-width glyphs

        visible = c.w.showSpacingSampleLine.get()

        km = self.getKerningManager(g.font)

        # Testing the KernNet in kerningManager
        #g1Name = c.w.previewGlyphLeftName.get() or 'H'
        #if g1Name in f:
        #    k = km.getKernNetKerning(f[g1Name], g, step=None)
        #    print(f'...KernNet {g1Name} {g.name} {k}')

        sampleContext = c.w.spacerMode.get()
        # 0    Glyphset
        # 1    According to similarity
        # 2    By group mode context
        # 3    By spacing mode context
        # 4    By kerning mode context
        # Get a spacing sample for the right amount of glyphs for the selected context
        sample = km.getSpacingSample(g, context=sampleContext, length=len(self.kerningLine)) 

        # @@@ TODO Move the generation of the line below to KerningManager method
        self.spacerGlyphPositions = [] # Reset the list of KerningLineGlyphPosition instances.

        prevName = None # Remember previous glyph name to get the kerning for the pair

        # We need to do this in 2 runs unfortunately, constructing the list of spacerGlyphPositions first,
        # in order to center the line by its total width.
        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine): # List of kerned glyph images
            if gIndex >= len(sample):
                break
            spaceG = f[sample[gIndex]]

            if prevName is None:
                k = 0
            else:
                k, groupK, kerningType = km.getKerning(prevName, spaceG.name) # Get the kerning from the groups of these glyphs

            if g.name == spaceG.name:
                color = self.SPACER_SELECTED_COLOR
            else:
                color = self.SPACER_FILL_COLOR
            sw = spaceG.width
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw
                sw += dw
            x += k # Correct start position of this glyph by kerning with the previous glyph
            self.spacerGlyphPositions.append(KerningLineGlyphPosition(spaceG, x, y, sw, h, k, color, gIndex, km.sampleKerningIndex + gIndex))
            x += sw
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw

            prevName = spaceG.name # Rembmer for next kerning pair

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + y * tan(radians(-f.info.italicAngle or 0))

        self.spacerWhiteBackground.setPosition((gpFirst.x + offsetX - 2*m, y + f.info.descender - m))
        self.spacerWhiteBackground.setSize((gpLast.x - gpFirst.x + gpLast.w + 4*m, h + 2*m))
        self.spacerWhiteBackground.setVisible(True)

        lineNumber = int(round(km.sampleKerningIndex/len(self.kerningLine)))
        numLines = int(round(len(sample)/len(self.kerningLine)))
        self.spacerKerningLineNumber.setPosition((gpFirst.x + offsetX - 2*m, (f.info.descender - 120)/self.KERN_SCALE))
        self.spacerKerningLineNumber.setText(f'{lineNumber}/{numLines} G-{len(g.font.groups)} K-{len(g.font.kerning)}')
        self.spacerKerningLineNumber.setVisible(True)

        self.kerningSelectedGlyphMarker.setVisible(False)

        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine):
            if gIndex >= len(self.spacerGlyphPositions):
                break
            gp = self.spacerGlyphPositions[gIndex]
            
            if self.mouseMovePoint is not None and gp.x <= self.mouseMovePoint.x/self.KERN_SCALE <= gp.x + gp.y:
                color = self.SPACER_HOVER_COLOR
            else:
                color = gp.fillColor 
            kerningGlyphLayer.setFillColor(color)
            kerningGlyphLayer.setPath(gp.glyph.getRepresentation("merz.CGPath"))
            kerningGlyphLayer.setPosition((gp.x + offsetX, y))
            kerningGlyphLayer.setVisible(visible)

            kerningNameLayer = self.kerningLineNames[gIndex]
            kerningNameLayer.setFillColor(color)
            kerningNameLayer.setText(gp.glyph.name)
            kerningNameLayer.setPosition((gp.x + offsetX + gp.w/2, y + f.info.descender))
            kerningNameLayer.setVisible(False) # Will be shown on mouse over hover

            # Show kerning value with the previous pair

            kerningLineValue = self.kerningLineValues[gIndex]
            if gp.k < 0:
                kerningLineValue.setFillColor((1, 0, 0, 1))
            elif gp.k == 0:
                kerningLineValue.setFillColor((0.5, 0.5, 0.5, 1))
            else: # gp.k > 0
                kerningLineValue.setFillColor((0, 0.5, 0, 1))
            kerningLineValue.setText(f'{round(gp.k)}')
            kerningLineValue.setPosition((gp.x + offsetX, y + f.info.descender - 12))
            kerningLineValue.setVisible(True)

            if gIndex == int(len(self.spacerGlyphPositions)/2):
                self.kerningSelectedGlyphMarker.setPosition((gp.x + offsetX, y + f.info.descender - 100))
                self.kerningSelectedGlyphMarker.setSize((g.width, 200))
                self.kerningSelectedGlyphMarker.setVisible(True)

        for n in range(gIndex, len(self.kerningLine)):
            self.kerningLine[n].setVisible(False)
            self.kerningLineNames[n].setVisible(False)
            self.kerningLineValues[n].setVisible(False)

    def mouseMoveSpacer(self, g, x, y, event):
        """Set the hoover color for the current selected glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        sy = y/self.KERN_SCALE
        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + sy * tan(radians(-g.font.info.italicAngle or 0))
        sx = x/self.KERN_SCALE - offsetX

        self.selectedHoverGlyphName = None

        for gIndex, gp in enumerate(self.spacerGlyphPositions):
            if gp.x <= sx <= gp.x + gp.w and gp.y - gp.h <= sy <= gp.y + gp.h:
                color = self.SPACER_HOVER_COLOR
                visible = True
                self.selectedHoverGlyphName = gp.name # Used to open the glyph if clicked on.

            elif gp.name == g.name:
                color = self.SPACER_SELECTED_COLOR
                visible = False
            
            else:
                color = self.SPACER_FILL_COLOR
                visible = False
                    
            self.kerningLineNames[gIndex].setFillColor(color)
            self.kerningLine[gIndex].setFillColor(color)
            self.kerningLineNames[gIndex].setVisible(visible)
                    
    def mouseDownSpacer(self, g, x, y, evnt):
        """Open Editor window on clicked glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        sy = y/self.KERN_SCALE
        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 - sy * tan(radians(-g.font.info.italicAngle or 0))
        sx = x/self.KERN_SCALE - offsetX

        if self.selectedHoverGlyphName is not None: # Is there a current hover selected
            OpenGlyphWindow(glyph=g.font[self.selectedHoverGlyphName], newWindow=False)

    def updateSpacer(self, info):
        """If the checkbox is set, then try to check and fix automated margins and width.
        Answer the boolean flag if something was changed to the glyph."""
        g = info['glyph']
        if g is None:
            return False # Nothing changed.
        return self.updateSpacerKerningGlyphs(g)

    def updateSpacerKerningGlyphs(self, g):
        km = self.getKerningManager(g.font)

        gNameLeft = km.kerningSample[max(0, km.sampleKerningIndex - 1)]
        gNameRight = km.kerningSample[min(len(km.kerningSample), km.sampleKerningIndex + 1)]

        gLeft = g.font[gNameLeft]
        gRight = g.font[gNameRight]

        kLeft, groupKLeft, kerningTypeLeft = km.getKerning(gNameLeft, g.name)
        kRight, groupKRight, kerningTypeRight = km.getKerning(g.name, gNameRight)

        # Recaclulate KernNet, since this the spacing or shape may have changed from last time
        knLeft = km.getKernNetKerning(gLeft, g) or 0
        knRight = km.getKernNetKerning(g, gRight) or 0

        y1 = g.font.info.descender - 120
        y2 = y1 - 120

        if kLeft < 0:
            color = (1, 0, 0, 1)
        elif kLeft == 0:
            color = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            color = (0, 0.5, 0, 1)

        if knLeft < 0:
            knColor = (1, 0, 0, 1)
        elif knLeft == 0:
            knColor = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            knColor = (0, 0.5, 0, 1)

        self.spacerGlyphLeft.setPath(gLeft.getRepresentation("merz.CGPath"))
        self.spacerGlyphLeft.setPosition((-gLeft.width - kLeft, 0))
        self.spacerGlyphLeft.setVisible(True)

        # Actual kerning value
        self.spacerGlyphKerningLeft.setText(str(kLeft))
        self.spacerGlyphKerningLeft.setPosition((self.italicX(g, kLeft/2, y1), y1))
        self.spacerGlyphKerningLeft.setFillColor(color)
        self.spacerGlyphKerningLeft.setVisible(True)

        # KernNet suggested kerning value
        self.spacerGlyphKernNetLeft.setText(f'*{knLeft}')
        self.spacerGlyphKernNetLeft.setPosition((self.italicX(g, kLeft/2, y2), y2))
        self.spacerGlyphKernNetLeft.setFillColor(knColor)
        self.spacerGlyphKernNetLeft.setVisible(True)

        if kRight < 0:
            color = (1, 0, 0, 1)
        elif kRight == 0:
            color = (0.5, 0.5, 0.5, 1)
        else: # kRight > 0
            color = (0, 0.5, 0, 1)

        if knRight < 0:
            knColor = (1, 0, 0, 1)
        elif knRight == 0:
            knColor = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            knColor = (0, 0.5, 0, 1)

        self.spacerGlyphRight.setPath(gRight.getRepresentation("merz.CGPath"))
        self.spacerGlyphRight.setPosition((g.width + kRight, 0))
        self.spacerGlyphRight.setVisible(True)

        # Actual kerning value
        self.spacerGlyphKerningRight.setText(str(kRight))
        self.spacerGlyphKerningRight.setPosition((self.italicX(g, g.width + kRight/2, y1), y1))
        self.spacerGlyphKerningRight.setFillColor(color)
        self.spacerGlyphKerningRight.setVisible(True)

        # KernNet suggested kerning value
        self.spacerGlyphKernNetRight.setText(f'{knRight}*')
        self.spacerGlyphKernNetRight.setPosition((self.italicX(g, g.width + kRight/2, y2), y2))
        self.spacerGlyphKernNetRight.setFillColor(knColor)
        self.spacerGlyphKernNetRight.setVisible(True)

        changed = self.checkFixGlyphSpacing(g)
        return changed

    def checkFixGlyphSpacing(self, g, updateMerz=True):
        changed = self.checkFixGlyphLeftMargin(g, updateMerz=updateMerz)
        changed |= self.checkFixGlyphRightMargin(g, updateMerz=updateMerz)
        #changed |= self.checkFixGlyphWidth(g)        
        return changed

    KEY_CENTER_GLYPH = '='
    KEY_INC_RIGHT_MARGIN_CAP = 'P'
    KEY_INC_RIGHT_MARGIN = 'p'
    KEY_DEC_RIGHT_MARGIN_CAP = 'O'
    KEY_DEC_RIGHT_MARGIN = 'o'
    KEY_INC_LEFT_MARGIN_CAP = 'I'
    KEY_INC_LEFT_MARGIN = 'i'
    KEY_DEC_LEFT_MARGIN_CAP = 'U'
    KEY_DEC_LEFT_MARGIN = 'u'

    KEY_INC_KERN2_CAP = '>'
    KEY_INC_KERN2 = '.'
    KEY_DEC_KERN2_CAP = '<'
    KEY_DEC_KERN2 = ','
    KEY_INC_KERN1_CAP = 'M'
    KEY_INC_KERN1 = 'm'
    KEY_DEC_KERN1_CAP = 'N'
    KEY_DEC_KERN1 = 'n'
    KEY_SET_KERNNET2 = '?'
    KEY_SET_KERN_0 = '/'

    def buildSpacer(self, y):
        """Build the assistant UI for anchor controls."""
        personalKey_eq = self.registerKeyStroke(self.KEY_CENTER_GLYPH, 'spacerCenterGlyph')

        # Incremental/decremental spacing by key

        personalKey_U = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN_CAP, 'spacerDecLeftMarginCap')
        personalKey_u = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN, 'spacerDecLeftMargin')
        personalKey_I = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN_CAP, 'spacerIncLeftMarginCap')
        personalKey_i = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN, 'spacerIncLeftMargin')

        personalKey_O = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN_CAP, 'spacerDecRightMarginCap')
        personalKey_o = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN, 'spacerDecRightMargin')
        personalKey_P = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN_CAP, 'spacerIncRightMarginCap')
        personalKey_p = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN, 'spacerIncRightMargin')

        # Incremental/decremental kerning by key

        personalKey_M = self.registerKeyStroke(self.KEY_INC_KERN1_CAP, 'spacerDecKern1Cap')
        personalKey_m = self.registerKeyStroke(self.KEY_INC_KERN1, 'spacerDecKern1')
        personalKey_N = self.registerKeyStroke(self.KEY_DEC_KERN1_CAP, 'spacerIncKern1Cap')
        personalKey_n = self.registerKeyStroke(self.KEY_DEC_KERN1, 'spacerIncKern1')

        personalKey_larger = self.registerKeyStroke(self.KEY_INC_KERN2_CAP, 'spacerIncKern2Cap')
        personalKey_period = self.registerKeyStroke(self.KEY_INC_KERN2, 'spacerIncKern2')
        personalKey_smaller = self.registerKeyStroke(self.KEY_DEC_KERN2_CAP, 'spacerDecKern2Cap')
        personalKey_comma = self.registerKeyStroke(self.KEY_DEC_KERN2, 'spacerDecKern2')

        personalKey_question = self.registerKeyStroke(self.KEY_SET_KERNNET2, 'spacerSetKernNet2')
        personalKey_slash = self.registerKeyStroke(self.KEY_SET_KERN_0, 'spacerSetKernClear2')

        # Kerning sample selection

        personalKey_pageHome = self.registerKeyStroke(self.PAGE_HOME_FUNCTION_KEY, 'spacerPreviousKerningGlyph') # (spacerPageHome) Actual key function "Home" here used as "Left": Previous kerning pair
        personalKey_pageEnd = self.registerKeyStroke(self.PAGE_END_FUNCTION_KEY, 'spacerNextKerningGlyph') # (spacerPageEnd) Actual key function "End" here used as "Right": Next kerning pair
        personalKey_pageUp = self.registerKeyStroke(self.PAGE_UP_FUNCTION_KEY, 'spacerPreviousKerningLine') # (spacerPageUp) Actual key function "Previous page" here used as: Previous kerning line
        personalKey_pageDown = self.registerKeyStroke(self.PAGE_DOWN_FUNCTION_KEY, 'spacerNextKerningLine') # (spacerPageDown) Actual key function "Next page" here used as: Next kerning line

        c = self.getController()
        C0, C1, C2, CW, L = self.C0, self.C1, self.C2, self.CW, self.L
        LL = 18
        c.w.autoSpace = CheckBox((C1, y, CW, L), 'Auto space', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.centerGlyphButton = Button((C2, y, CW, L), f'Center width [{personalKey_eq}]', callback=self.spacerCenterGlyphCallback)
        y += L
        c.w.splitSimScripts = CheckBox((C0, y, CW, L), 'Split Sim scripts', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.showSpacingSampleLine = CheckBox((C1, y, CW, L), 'Show sample line', value=True, sizeStyle='small', callback=self.updateEditor)
        
        # Decrement/Increment Left Margin is imaginary pushing on the sidebearing, not on the glyph.
        c.w.incLeftMarginButton = Button((C2, y, CW/4, L), f'<[{personalKey_u}]', callback=self.spacerIncLeftMarginCallback)
        c.w.decLeftMarginButton = Button((C2+CW/4, y, CW/4, L), f'[{personalKey_i}]>', callback=self.spacerDecLeftMarginCallback)
        c.w.decRightMarginButton = Button((C2+2*CW/4, y, CW/4, L), f'<[{personalKey_o}]', callback=self.spacerDecRightMarginCallback)
        c.w.incRightMarginButton = Button((C2+3*CW/4, y, CW/4, L), f'[{personalKey_p}]>', callback=self.spacerIncRightMarginCallback)
        y += L
        c.w.spacerMode = RadioGroup((C0, y, 2*CW, L), ('Glyphs', 'Similar', 'Group', 'Space', 'Kern'), isVertical=False, sizeStyle='small', callback=self.updateEditor)
        c.w.spacerMode.set(1)
        c.w.kerningSamplePattern1 = EditText((C2, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 1
        c.w.kerningSampleValue = EditText((C2+CW/2-18, y, 36, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning value range sample group 1
        c.w.kerningSamplePattern2 = EditText((C2+CW/2+18, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 2
        #c.w.decKern2Button = Button((C2, y, CW/4, L), '<[%s]' % personalKey_m, callback=self.spacerDecKern2Callback)
        #c.w.incKern2Button = Button((C2+CW/4, y, CW/4, L), '[%s]>' % personalKey_n, callback=self.spacerIncKern2Callback)
        #c.w.decKern1Button = Button((C2+2*CW/4, y, CW/4, L), '<[%s]' % personalKey_period, callback=self.spacerDecKern1Callback)
        #c.w.incKern1Button = Button((C2+3*CW/4, y, CW/4, L), '[%s]>' % personalKey_comma, callback=self.spacerIncKern1Callback)
        y += L
        c.w.autoSpaceAllButton = Button((C0, y, CW, L), 'Auto space all', callback=self.autoSpaceAllCallback)
        c.w.fixReportedSpacingDifferences = CheckBox((C1, y, CW, L), 'Fix reported', value=False, sizeStyle='small')
        c.w.reportSpacingButton = Button((C2, y, CW, L), 'Report spacing', callback=self.reportSpacingCallback)
        y += L + 10
        c.w.autoSpaceFontButton = Button((C0, y, CW, L), 'Auto space font', callback=self.autoSpaceFontCallback)
        y += L + 10
        c.w.factorKernNetTextBox = EditText((C0, y, 48, L))
        c.w.factorKernNetTextBox.set('1.2')
        c.w.calibrateKernNetTextBox = EditText((C1, y, 48, L))
        c.w.calibrateKernNetTextBox.set('0')
        c.w.autoKernAllGroupsButton = Button((C2, y, CW, L), 'Auto kern groups', callback=self.autoKernGroupsCallback)
        c.w.autoKernAllGroupsButton.enable(False)
        y += L + 10
        c.w.spacerEndLine = HorizontalLine((self.M, y, -self.M, 1))
        c.w.spacerEndLine2 = HorizontalLine((self.M, y, -self.M, 1))
        y += L/5

        return y

    def makeKerningSampleCallback(self, sender):
        """One of the kerning sample filters changed, let de kerning manager make a new kerning sample."""
        c = self.getController()
        g = self.getCurrentGlyph()
        km = self.getKerningManager(g.font)
        km.kerningSampleFilter1 = c.w.kerningSamplePattern1.get() or None
        km.kerningSampleValue = int(c.w.kerningSampleValue.get() or 0) or None
        km.kerningSampleFilter2 = c.w.kerningSamplePattern2.get() or None

        g.changed()

    def autoSpaceAllCallback(self, sender):
        """Auto space all UFO's in the family, recursively applying all rules until that base glyph. Keep track of the glyphs 
        that were modified to avoid double work. Report on the glypns that got changed."""
        print('--- Auto spacing all masters')
        f = self.getCurrentFont()
        parentPath = self.filePath2ParentPath(f.path)

        for pth in self.getUfoPaths(parentPath):
            f = self.getFont(pth)
            print(f'... Auto spacing {f.path.split("/")[-1]}')
            for g in f: # First check all glyphs without components
                if g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            for g in f: # Then check all glyphs with components
                if not g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            # Watch out: this will auto-save the adjusted font
            f.save()

    def autoSpaceFontCallback(self, sender):
        """Auto space the current font, recursively applying all rules until that base glyph. Keep track of the glyphs 
        that were modified to avoid double work. Report on the glypns that got changed."""
        print('--- Auto spacing all masters')
        f = self.getCurrentFont()
        print(f'... Auto spacing {f.path.split("/")[-1]}')
        for g in f: # First check all glyphs without components
            if g.components:
                continue
            changed = self.checkFixGlyphSpacing(g, updateMerz=False)
            if changed:
                g.changed()
        for g in f: # Then check all glyphs with components
            if not g.components:
                continue
            changed = self.checkFixGlyphSpacing(g, updateMerz=False)
            if changed:
                g.changed()
        # Watch out: this will auto-save the adjusted font
        f.save()

    def autoKernGroupsCallback(self, sender):
        """Auto kern all groups and kerning pairs for the given template for all UFO's in the family.
        Report on the groups and pairs that got changed. Only perform real changes if the safety switch is enabled."""
        print('--- Auto kern all masters')
        f = self.getCurrentFont()
        km = self.getKerningManager(f)
        try:
            factor = float(self.w.factorKernNetTextBox.get())
        except ValueError:
            factor = 1
        try:
            calibrate = int(self.w.calibrateKernNetTextBox.get())
        except ValueError:
            calibrate = 0
        km.kernGroups(factor=factor, calibrate=calibrate, verbose=True)

    def reportSpacingCallback(self, sender):
        """Report/fix margins for the current font that don't fit the epexted value as it would have been auto spaced.
        This method both allowed to get feedback on how accurate the autospacer works. And it gives a list of glyphs
        that need extra attention."""
        f = self.getCurrentFont()
        changed = self.reportSpacing(self, f)
        if changed:
            f.changed()

    def reportSpacing(self, f, doFix=False):
        changed = False
        c = self.getController()
        md = self.getMasterData(f)
        km = self.getKerningManager(f)

        # First check all glyphs without component
        for g in f:
            if g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        # Then check all glyphs with components
        for g in f:
            if not g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        return changed

    def spacerDecLeftMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustLeftMarginByUnits(g, -1)
            g.changed()

    def spacerIncLeftMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustLeftMarginByUnits(g, 1)
            g.changed()

    def spacerDecRightMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustRightMarginByUnits(g, -1)
            g.changed()

    def spacerIncRightMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustRightMarginByUnits(g, 1)
            g.changed()


    def spacerDecLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -5)
        g.changed()

    def spacerDecLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 5)
        g.changed()

    def spacerIncLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, -5)
        g.changed()

    def spacerDecRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, 5)
        g.changed()

    def spacerIncRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()

    #   K E R N I N G  K E Y S

    """
    def spacerDecKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()

    """

    def spacerDecKern2Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, -5, capLock=capLock)

    def spacerDecKern2(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, -1, capLock=capLock)

    def spacerIncKern2Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, 5, capLock=capLock)

    def spacerIncKern2(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, 1, capLock=capLock)

    def spacerDecKern1Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, -5, capLock=capLock)

    def spacerDecKern1(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, -1, capLock=capLock)

    def spacerIncKern1Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, 5, capLock=capLock)

    def spacerIncKern1(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, 1, capLock=capLock)
    
    def spacerSetKernNet2(self, g, c, event):
        """Set the right kerning value to the calculated KernNet kerning value."""
        km = self.getKerningManager(g.font)
        kernGlyphName2 = km.kerningSample[km.sampleKerningIndex + 1]
        knRight = km.getKernNetKerning(g, g.font[kernGlyphName2]) or 0 # Needs glyphs, not glyph names
        self._adjustRightKerning(g, newK=knRight)

    def spacerSetKernClear2(self, g, c, event):
        """Clear the right kerning value"""
        self._adjustRightKerning(g, newK=0)

    #   S A M P L E  K E Y S

    def spacerPreviousKerningLine(self, g, c, event):
        km = self.getKerningManager(g.font)
        dec = len(self.kerningLine)
        if event['shiftDown']:
            dec *= 10
            if event['optionDown']:
                dec *= 10
        
        km.sampleKerningIndex = km.sampleKerningIndex - dec # km property will take care boundaries
        prevGlyphName = km.kerningSample[km.sampleKerningIndex]
        if prevGlyphName in g.font:
            prevGlyph = g.font[prevGlyphName]
            self.openGlyphWindow(prevGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(prevGlyph)
            self.updateMerzSpacerKerningLine(prevGlyph)
        else:
            print(f'### spacerPreviousKerningLine: Cannot find {prevGlyphName}')

    def spacerNextKerningLine(self, g, c, event):
        km = self.getKerningManager(g.font)
        inc = len(self.kerningLine) # Go to next kerning line
        if event['shiftDown']:
            inc *= 10
            if event['optionDown']:
                inc *= 10

        km.sampleKerningIndex = km.sampleKerningIndex + inc # km property will take care of boundaries
        nextGlyphName = km.kerningSample[km.sampleKerningIndex]
        if nextGlyphName in g.font:
            nextGlyph = g.font[nextGlyphName]
            self.openGlyphWindow(nextGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(nextGlyph)
            self.updateMerzSpacerKerningLine(nextGlyph)
        else:
            print(f'### spacerNextKerningLine: Cannot find {nextGlyphName}')

    def spacerPreviousKerningGlyph(self, g, c, event):
        km = self.getKerningManager(g.font)
        if event['optionDown']:
            dec = 1 # Next is next glyph
        elif event['shiftDown']:
            dec = 10 # Skip a chunk
        else: # Previous is 2, to skip the pair
            dec = 2

        kerningSample = km.kerningSample
        km.sampleKerningIndex = km.sampleKerningIndex - dec # km property will take care of boundaries
        prevGlyphName = kerningSample[km.sampleKerningIndex]
        if prevGlyphName in g.font:
            prevGlyph = g.font[prevGlyphName]
            self.openGlyphWindow(prevGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(prevGlyph)
            self.updateMerzSpacerKerningLine(prevGlyph)
        else:
            print(f'### spacerPreviousKerningGlyph: Cannot find {prevGlyphName}')

    def spacerNextKerningGlyph(self, g, c, event):
        km = self.getKerningManager(g.font)
        if event['optionDown']:
            inc = 1 # Next is next glyph
        elif event['shiftDown']:
            inc = 10 # Skip a chunk
        else: # Next is 2, to skip the pair
            inc = 2

        kerningSample = km.kerningSample
        km.sampleKerningIndex = km.sampleKerningIndex + inc # km property will take care of boundaries
        if km.sampleKerningIndex < len(kerningSample):
            nextGlyphName = kerningSample[km.sampleKerningIndex]
            if nextGlyphName in g.font:
                nextGlyph = g.font[nextGlyphName]
                self.openGlyphWindow(nextGlyph, newWindow=False)
                self.updateSpacerKerningGlyphs(nextGlyph)
                self.updateMerzSpacerKerningLine(nextGlyph)
            else:
                print(f'### spacerNextKerningGlyph: Cannot find {nextGlyphName}')

    #   A D J U S T  S P A C I N G

    SPACING_UNIT = KERNING_UNIT = 4

    def _adjustLeftMarginByUnits(self, g, value): 
        if self.isUpdating:
            return
        f = g.font        
        g.angledLeftMargin = int(round(g.angledLeftMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT
                          
    def _adjustRightMarginByUnits(self, g, value): # This moved to TYPETR-Assistants/KerningAssistant-005.py
        if self.isUpdating:
            return
        f = g.font
        g.angledRightMargin = int(round(g.angledRightMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT

    """
        #    K E R N I N G

        elif characters in '.>': # Increment right kerning
            if shiftDown:
                self._adjustRightKerning(g, 5) # 20
            else:
                self._adjustRightKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in ',<': # Decrement right kerning
            if shiftDown:
                self._adjustRightKerning(g, -5) # 20
            else:
                self._adjustRightKerning(g, -1) # 4
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Mm': # Decrement left kerning
            if shiftDown:
                self._adjustLeftKerning(g, -5) # 20
            else:
                self._adjustLeftKerning(g, -1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Nn': # Increment left kerning
            if shiftDown:
                self._adjustLeftKerning(g, 5) # 20
            else:
                self._adjustLeftKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        """

    def _adjustLeftKerning(self, g, value=None, newK=None, capLock=False):
        """ 
        Two ways of usage:
        • value is relative adjustment
        • newK is setting new kerning value.
           
            3 = glyph<-->glyph # Not used
            2 = group<-->glyph
            1 = glyph<-->group
            0 or None = group<-->group
        """
        assert value is not None or newK is not None
        f = g.font
        km = self.getKerningManager(f)
        kernGlyphName1 = km.kerningSample[km.sampleKerningIndex - 1]
        k, groupK, kerningType = km.getKerning(kernGlyphName1, g.name)
        if newK is not None:
            k = newK # Set this value, probably predicted.
        else: # Adjust relative by rounded value
            k = int(round(k/self.KERNING_UNIT))*self.KERNING_UNIT + value * self.KERNING_UNIT
        if not kerningType and capLock:
            kerningType = 2 # group<-->glyph
        elif kerningType == 2 and capLock:
            kerningType = 3 # glyph<-->glyph 
        changed = km.setKerning(kernGlyphName1, g.name, k, kerningType)
        if changed:
            print(f'... Kerning left changed to {k}')
            f.changed()
            #g.width += 1
            #g.width -= 1 # Seems to be necessarfy to force glyph change update.
            #g.glyphChangedUpdate() Does not work?
            #g.changed()
            # Does not seem to work through g.changed. Call directly to update Merz objects.
            self.updateSpacerKerningGlyphs(g)
            self.updateMerzSpacerKerningLine(g)

    def _adjustRightKerning(self, g, value=None, newK=None, capLock=False):
        """    
        Two ways of usage:
        • value is relative adjustment
        • newK is setting new kerning value.

            3 = glyph<-->glyph # Not used
            2 = group<-->glyph
            1 = glyph<-->group
            0 or None = group<-->group
        """
        assert value is not None or newK is not None
        f = g.font
        km = self.getKerningManager(f)
        unit = 4
        kernGlyphName2 = km.kerningSample[km.sampleKerningIndex + 1]
        k, groupK, kerningType = km.getKerning(g.name, kernGlyphName2)
        if newK is not None:
            k = newK # Set this value, probably predicted.
        else: # Adjust relative by rounded value
            k = int(round(k/self.KERNING_UNIT))*self.KERNING_UNIT + value * self.KERNING_UNIT
        if not kerningType and capLock:
            kerningType = 1 # glyph<-->group
        elif kerningType == 1 and capLock:
            kerningType = 3 # glyph<-->glyph
        changed = km.setKerning(g.name, kernGlyphName2, k, kerningType)
        if changed:
            print(f'... Kerning right changed to {k}')
            f.changed()
            #g.width += 1
            #g.width -= 1 # Seems to be necessarfy to force glyph change update.
            #g.glyphChangedUpdate() Does not work?
            #g.changed()
            # Does not seem to work through g.changed. Call directly to update Merz objects.
            self.updateSpacerKerningGlyphs(g)
            self.updateMerzSpacerKerningLine(g)

    #   G U E S S  S P A C I N G  &  K E R N I N G

    def checkFixGlyphWidth(self, g, km=None):
        """Use the KerningManager for the current font to determine the best width for this glyph.
        Check if this glyph should have its width altered. If it has components, then fix those first.
        If something changed, then answer True. 
        """
        changed = False
        if km is None:
            km = self.getKerningManager(g.font)

        label = ''
        color = 0, 0, 0, 0
    
        width = km.getWidth(g)
        if width is not None:
            changed = self._fixGlyphWidth(g, width)
            label = f'Width={g.width}' 
            color = self.SPACER_FIXED_WIDTH_MARKER_COLOR

        self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
        self.fixedSpaceMarkerRight.setFillColor(color)
        self.fixedSpaceMarkerRight.setVisible(True)

        self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*4))
        self.rightSpaceSourceLabel.setText(label)
        self.rightSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphLeftMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best left margin for this glyph.
        Check if this glyph should have its left margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        if c is None: # The window may have been closed
            return False # Nothing happened

        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        if c.w.autoSpace.get():

            md = self.getMasterData(g.font)
            gd = md.glyphSet[g.name]
            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphLeftMargin: Cannot find GlyphData for /{g.name}')
            
            elif gd.l == 'off':
                label = f'Auto-spacing is off'
                print(f'... checkFixGlyphLeftMargin: /{g.name} auto-spacing is off')

            # First check if there is a masterData spacing source defined, that overwrites all other spacing rules
            elif md.spacingSrcUFOPath is not None and gd.w not in (0, None):  # Only if defined and the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    lm = src[g.name].angledLeftMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledLeftMargin))}+{md.spacingOffset}={int(round(lm))}'
                    changed = km.fixLeftMargin(g, lm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.leftMargin is None: # Empty glyph, can't set left/right margin
                pass

            else: # Otherwise 
                referenceLabel = gd.leftSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixLeftMarginByGlyphSetReference(g) # Fix the left margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledLeftMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else: # Strategy #2, see if there is a similar glyph to copy the left margin from.
                    similarName2 = km.getSimilarBaseName2(g)
                    if similarName2 is not None:
                        srcG2 = g.font[similarName2]
                        if similarName2 == g.name:
                            label = f'Sim base /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixLeftMargin(g, srcG2.angledLeftMargin, label)
                    else:
                        label = f'{int(round(g.angledLeftMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledLeftMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5

        if updateMerz:
            self.fixedSpaceMarkerLeft.setPosition((-self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerLeft.setFillColor(fillColor)
            self.fixedSpaceMarkerLeft.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerLeft.setVisible(True)

            self.leftSpaceSourceLabel.setPosition((0, -self.SPACER_MARKER_R*2))
            self.leftSpaceSourceLabel.setText(label)
            self.leftSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphRightMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best right margin for this glyph. 
        Check if this glyph should have its right margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        if c is None: # Window may have been closed already
            return changed

        if c.w.autoSpace.get():

            md = self.getMasterData(g.font)
            gd = md.glyphSet[g.name]
            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphRightMargin: Cannot find GlyphData for /{g.name}')

            elif isinstance(gd.w, (int, float)):
                w = int(round(gd.w))
                if g.width != w:
                    g.width = w
                    print(f'Set width of /{g.name} to {w}')
                    changed = True

            elif gd.w == 'tab':

                if g.width != md.tabWidth:
                    g.width = md.tabWidth
                    print(f'Set tab width of /{g.name} to {md.tabWidth}')
                    changed = True

            elif gd.r == 'off':
                label = f'Auto-spacing is off'
                print(f'... checkFixGlyphRightMargin: /{g.name} auto-spacing is off')

            elif md.spacingSrcUFOPath is not None and g.width: # Only if defined and if the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    rm = src[g.name].angledRightMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledRightMargin))}+{md.spacingOffset}={int(round(rm))}'
                    changed = km.fixRightMargin(g, rm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.rightMargin is None: # Empty glyph, can't set left/right margin
                pass

            else:
                referenceLabel = gd.rightSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixRightMarginByGlyphSetReference(g) # Fix the right margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledRightMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else:
                    similarName1 = km.getSimilarBaseName1(g)
                    if similarName1 is not None:
                        srcG1 = g.font[similarName1]
                        if similarName1 == g.name:
                            label = f'Sim base /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixRightMargin(g, srcG1.angledRightMargin, label)
                    else:
                        label = f'{int(round(g.angledRightMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledRightMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5
        label += f'\n(w={g.width})'

        if updateMerz:
            self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerRight.setFillColor(fillColor)
            self.fixedSpaceMarkerRight.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerRight.setVisible(True)
            
            self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*2))
            self.rightSpaceSourceLabel.setText(label)
            self.rightSpaceSourceLabel.setVisible(True)

        return changed
    
    def spacerCenterGlyphCallback(self, sender):
        """Callback from button. Center the current glyph on its width, if not done autmatically."""
        g = self.getCurrentGlyph()
        if g is not None:
            if self.spacerCenterGlyph(g):
                g.changed()

    def spacerCenterGlyph(self, g, c, event):     
        """Snap the selected points of the current glyph onto points that are within range on the background glyph."""
        changed = False
        lm = g.angledLeftMargin
        rm = g.angledRightMargin
        w = g.width
        if lm is not None:
            g.angledLeftMargin = (lm + rm)/2
            g.width = w
            changed = True

        return changed
