# -*- coding: UTF-8 -*-
# ------------------------------------------------------------------------------
#     Copyright (c) 2023+ TYPETR
#     Usage by MIT License
# ..............................................................................
#
#   spacer.py
#
#   TODO
#   - Auto sim spacing
#   - Sample line or buttons line for alternative spacing masters
#   - Kerning line
#   - Spacing and kerning keys
#   - Set Similarity zones
#
import sys
from math import *
from vanilla import *
from AppKit import *
from random import choice

from mojo.UI import OpenGlyphWindow
from mojo.roboFont import CurrentFont

# Add paths to libs in sibling repositories
PATHS = ('../TYPETR-Assistants/',)
for path in PATHS:
    if not path in sys.path:
        print('@@@ Append to sys.path', path)
        sys.path.append(path)

from assistantLib.assistantParts.baseAssistantPart import BaseAssistantPart
from assistantLib.assistantParts.data import * # Import anchors names

from assistantLib.assistantParts.glyphsets.groupBaseGlyphs import KERN_GROUPS

ARROW_KEYS = [NSUpArrowFunctionKey, NSDownArrowFunctionKey,
        NSLeftArrowFunctionKey, NSRightArrowFunctionKey, NSPageUpFunctionKey,
        NSPageDownFunctionKey, NSHomeFunctionKey, NSEndFunctionKey]

class KerningLineGlyphPosition:
    """Element that holds position and name of glyphs in the spacer/kerning line. This makes it easier 
    for mouseover to detect clicks on the line"""
    def __init__(self, glyph, x, y, w, h, k, kerningType, fillColor, lineIndex, sampleKerningIndex=None):
        self.glyph = glyph # RGlyph object 
        self.name = glyph.name
        self.x = x
        self.y = y
        self.w = w # Width of the glyph
        self.h = h # Height of the box
        self.k = k # Kerning with previoud glyph
        self.kerningType = kerningType # Can be None if the caller does not have the info availalbe
        self.fillColor = fillColor
        self.lineIndex = lineIndex
        self.sampleKerningIndex = sampleKerningIndex

class AssistantPartSpacer(BaseAssistantPart):
    """The Spacer assistant part handles all margins and widths that can be automated.
    It makes guesses based on the names of glyphs, existing components, values in the MasterData
    and Erik van Blokland's Similarity.
    The assistant part gives feedback about where the automated values came from, so it's easier to debug.
    """

    KERN_LINE_LENGTH = 48 # Number of glyphs on kerning line
    KERN_SCALE = 0.12 #0.2 Scaler for glyphs on kerning line

    SPACER_FIXED_WIDTH_MARKER_COLOR = 0.5, 0.5, 0.5, 0.5
    SPACER_FIXED_MARGIN_MARKER_COLOR = 0.8, 0.2, 0.4, 0.7
    SPACER_LABEL_FONT = 'Verdana'
    SPACER_LABEL_SIZE = 14
    SPACER_MARKER_R = 32 # Radius of space marker

    SPACER_KERNING_LABEL_SIZE = 24

    #SPACER_FILL_COLOR = 0.2, 0.2, 0.2, 1 # Default color, not entirely black
    SPACER_FILL_COLOR = 0, 0, 0, 1 # All black for final kerning check round
    #SPACER_SIDE_OVERLAY_FILL_COLOR = 0.5, 0.5, 0.5, 0.5 # Default color for sides overlay kerning. Set to SPACER_FILL_COLOR if working on kerning.
    SPACER_SIDE_OVERLAY_FILL_COLOR = 0, 0, 0, 1 # Default color for sides overlay kerning. Set to SPACER_FILL_COLOR if working on kerning.
    SPACER_SELECTED_COLOR = SPACER_FILL_COLOR #0.2, 0.2, 0.5, 1 # Current glyph
    SPACER_HOVER_COLOR = 1, 0, 0, 1 # Mouse goes over the element
    SPACER_LINE_BOX_COLOR = 0, 0, 0, 0.5 # Stroke color of space box

    #SPACER_FILL_GLYPH_COLOR = 0, 0, 0, 0.9 # Fill color for large sample glyphs on left and right side

    def initMerzSpacer(self, container):
        """Define the Merz elements for feedback about where margins/width comes from."""

        #    K E R N I N G  L I N E
    
        #km.sampleKerningIndex: offset into the full sample, generated by KerningManager for a certain mode
        self.spacerGlyphPositions = [] # KerningLineGlyphPosition instances, adjusted by the line lenght, to center on current glyph.width/2
        self.spacerGlyphGroupPositions1 = [] # KerningLineGlyphPosition instances for the GroupKerningLines1
        self.spacerGlyphGroupPositions2 = [] # KerningLineGlyphPosition instances for the GroupKerningLines2
        self.selectedHoverGlyphName = None # Name of glyph that is currently hovered over in the spacing line.

        self.kerningLine = [] # List of kerned/spaced glyph image layers, also buttons
        self.kerningGroupLine1 = [] # List of group1 permutations
        self.kerningGroupLine2 = [] # Lust of group2 permutations
        self.kerningLineValues = [] # List of kerning value layers
        self.kerningLineNames = [] # List of glyph name layers
        self.kerningLineBoxes = [] # List of kerned glyph em-boxes

        self.kerningSelectedGlyph = None # Name of the glyph selected by the kerning editor

        # If None, then initialize from kerningManager.splitKerningTypes(), anwering a list of 5 dicionaries that contain
        # the (groupGroup, groupGlyph, glyphGroup, glyphGlyph, bad) kerning pairs, ordered by type. 
        # Note that should only be used to show the amount of kerning types. It cannot be used to alter any of kerning.
        # That should be done by kerningMananger.setKerning() or directly info the f.kerning
        self.kerningTypes = None 

        # Flag to indicate that the two group kerning lines need to be updated
        self.needsGroupKerningLinesUpdate = True

        # Showing actual kerning below left and right glyph in EditorWindow
        self.spacerGlyphKerningLeft = container.appendTextLineSublayer(name="spacerGlyphKerningLeft",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKerningLeft.setHorizontalAlignment('right')
        
        self.spacerGlyphKerningRight = container.appendTextLineSublayer(name="spacerGlyphKerningRight",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKerningRight.setHorizontalAlignment('left')
        
        # Showing suggested KernNet value below left and right glyph in EditorWindow

        self.spacerGlyphKernNetLeft = container.appendTextLineSublayer(name="spacerGlyphKernNetLeft",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKernNetLeft.setHorizontalAlignment('right')
        
        self.spacerGlyphKernNetRight = container.appendTextLineSublayer(name="spacerGlyphKernNetRight",
            position=(0, 0),
            text='',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            #fillColor depends on kerning value
            visible=False,
        )
        self.spacerGlyphKernNetRight.setHorizontalAlignment('left')
        
        # White rectangle as background of spacer/kerning line
        
        self.spacerWhiteBackground = container.appendRectangleSublayer(name="spacesWhiteBackground",
            position=(0, 0),
            size=(1, 1),
            fillColor=(1, 1, 1, 0.6), # Slightly transparant, so rest of EditorWindow can be seen through.
            visible=False,
        )
        self.spacerWhiteBackground.addScaleTransformation(self.KERN_SCALE)

        # Current line number in the kerning sample (Corresponding with the proof line numbering)
        # Also showing the number of groups and kerning pairs
        
        self.spacerKerningLineNumber = container.appendTextLineSublayer(name="spacerKerningLineNumber",
            position=(0, 0),
            text='X',
            font='Verdana',
            pointSize=self.SPACER_KERNING_LABEL_SIZE,
            fillColor=(0.4, 0.4, 0.4, 1),
            visible=False,
        )
        self.spacerKerningLineNumber.addScaleTransformation(self.KERN_SCALE)
        self.spacerKerningLineNumber.setHorizontalAlignment('left')
        
        # Glyphs cells on the spacer/kerning line

        for gIndex in range(self.KERN_LINE_LENGTH):
            # Previewing current glyphs on left/right side.        
            im = container.appendPathSublayer(
                name=f'kernedGlyph-{gIndex}',
                position=(0, 0),
                fillColor=self.SPACER_FILL_COLOR,
                visible=False,
            )
            im.addScaleTransformation(self.KERN_SCALE)
            self.kerningLine.append(im)
            
            kerningLineValue = container.appendTextLineSublayer(
                name=f'kernedValue-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Can be red (negative kerning) or green (positive kerning)
                visible=False,
            )
            kerningLineValue.addScaleTransformation(self.KERN_SCALE)
            kerningLineValue.setHorizontalAlignment('center')
            self.kerningLineValues.append(kerningLineValue)

            kerningLineBox = container.appendRectangleSublayer(
                name=f'kernedBox-{gIndex}',
                position=(0, 0),
                size=(1, 1),
                fillColor=None,
                strokeColor=self.SPACER_LINE_BOX_COLOR,
                strokeWidth=1,
                visible=False,
            )
            kerningLineBox.addScaleTransformation(self.KERN_SCALE)
            self.kerningLineBoxes.append(kerningLineBox)

            kerningLineName = container.appendTextLineSublayer(
                name=f'kernedName-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Default line glyph color
                visible=False,
            )
            kerningLineName.addScaleTransformation(self.KERN_SCALE)
            kerningLineName.setHorizontalAlignment('center')
            self.kerningLineNames.append(kerningLineName)

            # Kerning line 1 & 2 showing group permutations

            im = container.appendPathSublayer(
                name=f'kernedGroup1-{gIndex}',
                position=(0, 0),
                fillColor=self.SPACER_FILL_COLOR,
                visible=False,
            )
            im.addScaleTransformation(self.KERN_SCALE)
            self.kerningGroupLine1.append(im)
            
            im = container.appendPathSublayer(
                name=f'kernedGroup2-{gIndex}',
                position=(0, 0),
                fillColor=self.SPACER_FILL_COLOR,
                visible=False,
            )
            im.addScaleTransformation(self.KERN_SCALE)
            self.kerningGroupLine2.append(im)
            

        # Full size in editor

        self.kerningSelectedGlyphMarker = container.appendRectangleSublayer(
            name='kerningSelectedGlyphMarker',
            position=(0, 0),
            size=(1, 20),
            fillColor=(1, 0, 0, 1),
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.kerningSelectedGlyphMarker.addScaleTransformation(self.KERN_SCALE)

        # Glyphs on the side in real size. Turn the Overlay glyphs off to avoid overlapping

        self.spacerGlyphLeft = container.appendPathSublayer(
            position=(0, 0),
            fillColor=self.SPACER_SIDE_OVERLAY_FILL_COLOR,
            visible=False,
        )
        self.spacerGlyphRight = container.appendPathSublayer(
            position=(0, 0),
            fillColor=self.SPACER_SIDE_OVERLAY_FILL_COLOR,
            visible=False,
        )

        self.kerning1Value = container.appendTextLineSublayer(
            name="kerning1Value",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning1Value.setHorizontalAlignment('center')

        self.kerning2Value = container.appendTextLineSublayer(
            name="kerning2Value",
            position=(0, 0),
            text='xxx\nxxx',
            font='Courier',
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning2Value.setHorizontalAlignment('center')

        self.kerningCursorBox = container.appendTextLineSublayer(
            name="kerningCursorBox",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=14,
            fillColor=(0.6, 0.6, 0.6, 1),
            visible=False,
        )


        #   S P A C I N G  M A R K E R S

        self.fixedSpaceMarkerLeft = container.appendOvalSublayer(name="spaceMarkerLeft",
            position=(-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
        )
        self.leftSpaceSourceLabel = container.appendTextLineSublayer(name="leftSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.leftSpaceSourceLabel.setHorizontalAlignment('right')
        
        self.fixedSpaceMarkerRight = container.appendOvalSublayer(name="spaceMarkerRight",
            position=(1000-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.rightSpaceSourceLabel = container.appendTextLineSublayer(name="rightSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.rightSpaceSourceLabel.setHorizontalAlignment('left')

    def updateMerzSpacer(self, info):
        """Update the spacing/kerning sample line"""
        c = self.getController()
        g = info['glyph']
        if g is None:
            return 
        if c.w.showSpacingSampleLine.get():
            self.updateMerzSpacerKerningLine(g)
        else:
            self.hideMerzSpacerKerningLine()
            g.changed()

    def hideMerzSpacerKerningLine(self):
        for kerningGlyphLayer in self.kerningLine:
            kerningGlyphLayer.setVisible(False)
        for kerningNameLayer in self.kerningLineNames:
            kerningNameLayer.setVisible(False)
        for kerningGlyphLayer in self.kerningGroupLine1:
            kerningGlyphLayer.setVisible(False)
        for kerningGlyphLayer in self.kerningGroupLine2:
            kerningGlyphLayer.setVisible(False)
        self.spacerWhiteBackground.setVisible(False)
        self.spacerKerningLineNumber.setVisible(False)

    def updateMerzSpacerKerningLine(self, g):
        """Update the spacing/kerning/sample line for the current glyphs and its settings."""
        c = self.getController()
        f = g.font

        h = f.info.unitsPerEm
        m = h/5 # Margin around white rectangle.
        x = 0 # Adjusted from the previous line calculation
        y = f.info.descender/self.KERN_SCALE - 1.5*m/self.KERN_SCALE
        k = None
        dw = f.info.unitsPerEm/5 # Extra width to zero-width glyphs

        visible = c.w.showSpacingSampleLine.get()

        km = self.getKerningManager(f)

        # Update the list of kerningTypes. This is an "expensive" operation, so we cache.
        # It's mostly to get an impressions how the kerning types are distributes in the f.kerning.
        # For a better view on the amounts an update should be done, or we need to do some bookkeeping outselves.
        # kerningTypes is a tuple of 5 kerning dictionaries where the types are split according
        # (group-group, group-glyph, glyph-group, glyph-glyph and bad). The bad dictionary is all kerning pairs
        # that refer to non-existing groups or non-existing glyphs. In principle it always should be empty,
        # otherwise kerning table needs to be cleaned up. 
        if self.kerningTypes is None:
            self.kerningTypes = km.splitKerningTypes()

        # Testing the KernNet in kerningManager
        #g1Name = c.w.previewGlyphLeftName.get() or 'H'
        #if g1Name in f:
        #    k = km.getKernNetKerning(f[g1Name], g, step=None)
        #    print(f'#### ... KernNet {g1Name} {g.name} {k}')

        sampleContext = c.w.spacerMode.get()
        # 0    Glyphset
        # 1    According to similarity
        # 2    By group mode context
        # 3    By spacing mode context
        # 4    By kerning mode context
        # Get a spacing sample for the right amount of glyphs for the selected context
        sample = km.getSpacingSample(g, context=sampleContext, length=len(self.kerningLine)) 

        # @@@ TODO Move the generation of the line below to KerningManager method
        self.spacerGlyphPositions = [] # Reset the list of KerningLineGlyphPosition instances.

        prevName = None # Remember previous glyph name to get the kerning for the pair

        glyphName1 = glyphName2 = None # Used for kerningGroupLines, names of glyph left & right of current glyph

        # We need to do this in 2 runs unfortunately, constructing the list of spacerGlyphPositions first,
        # in order to center the line by its total width.
        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine): # List of kerned glyph images
            if gIndex >= len(sample):
                break
            spaceG = f[sample[gIndex]]

            if prevName is None:
                k = 0
                kerningType = None
            else:
                k, groupK, kerningType = km.getKerning(prevName, spaceG.name) # Get the kerning from the groups of these glyphs

            if g.name == spaceG.name:
                color = self.SPACER_SELECTED_COLOR
            else:
                color = self.SPACER_FILL_COLOR
            sw = spaceG.width
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw
                sw += dw
            x += k # Correct start position of this glyph by kerning with the previous glyph
            self.spacerGlyphPositions.append(KerningLineGlyphPosition(spaceG, x, y, sw, h, k, kerningType, color, gIndex, km.sampleKerningIndex + gIndex))
            x += sw
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw

            prevName = spaceG.name # Remember for next kerning pair

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        gpPrev = gpCurr = gpNext = None # Set for reference of KerningGroupLines

        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + y * tan(radians(-(f.info.italicAngle or 0)))

        self.spacerWhiteBackground.setPosition((gpFirst.x + offsetX - 2*m, y + f.info.descender - m))
        self.spacerWhiteBackground.setSize((gpLast.x - gpFirst.x + gpLast.w + 4*m, h + 2*m))
        self.spacerWhiteBackground.setVisible(True)

        lineNumber = int(round(km.sampleKerningIndex/len(self.kerningLine)))
        numLines = int(round(len(sample)/len(self.kerningLine)))
        self.spacerKerningLineNumber.setPosition((gpFirst.x + offsetX - 2*m, (f.info.descender - 48)/self.KERN_SCALE))
        self.spacerKerningLineNumber.setText(f'{lineNumber}/{numLines} G-{len(f.groups)} K-{len(f.kerning)} GG-{len(self.kerningTypes[0])} Gg-{len(self.kerningTypes[1])} gG-{len(self.kerningTypes[2])} gg-{len(self.kerningTypes[3])} bad-{len(self.kerningTypes[4])}')
        self.spacerKerningLineNumber.setVisible(True)

        self.kerningSelectedGlyphMarker.setVisible(False)

        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine):
            if gIndex >= len(self.spacerGlyphPositions):
                break
            gp = self.spacerGlyphPositions[gIndex]
            
            if self.mouseMovePoint is not None and gp.x <= self.mouseMovePoint.x/self.KERN_SCALE <= gp.x + gp.y:
                color = self.SPACER_HOVER_COLOR
            else:
                color = gp.fillColor 
            kerningGlyphLayer.setFillColor(color)
            kerningGlyphLayer.setPath(gp.glyph.getRepresentation("merz.CGPath"))
            kerningGlyphLayer.setPosition((gp.x + offsetX, y))
            kerningGlyphLayer.setVisible(visible)

            kerningNameLayer = self.kerningLineNames[gIndex]
            kerningNameLayer.setFillColor(color)
            kerningNameLayer.setText(gp.glyph.name)
            kerningNameLayer.setPosition((gp.x + offsetX + gp.w/2, y + f.info.descender*3))
            kerningNameLayer.setVisible(False) # Will be shown on mouse over hover

            # Show kerning value with the previous pair

            kerningLineValue = self.kerningLineValues[gIndex]
            if gp.k < 0:
                kerningLineValue.setFillColor((1, 0, 0, 1))
            elif gp.k == 0:
                kerningLineValue.setFillColor((0.5, 0.5, 0.5, 1))
            else: # gp.k > 0
                kerningLineValue.setFillColor((0, 0.5, 0, 1))

            kerningLineValue.setText(f'{round(gp.k)}')
            kerningLineValue.setPosition((gp.x + offsetX, y + f.info.descender - 12))
            kerningLineValue.setVisible(True)

            midIndex = int(len(self.spacerGlyphPositions)/2)
            if gIndex == midIndex - 1:
                gpPrev = gp # Save for reference of kerningGroupLines
            elif gIndex == midIndex:
                self.kerningSelectedGlyphMarker.setPosition((gp.x + offsetX, y + f.info.descender - 100))
                self.kerningSelectedGlyphMarker.setSize((g.width, 200))
                self.kerningSelectedGlyphMarker.setVisible(True)
                gpCurr = gp # Save for reverence of kerningGroupLines
            elif gIndex == midIndex + 1:
                gpNext = gp # Save for reference of kerningGroupLines

        for n in range(gIndex, len(self.kerningLine)):
            self.kerningLine[n].setVisible(False)
            self.kerningLineNames[n].setVisible(False)
            self.kerningLineValues[n].setVisible(False)

        # Set Group1-Group2 permutations line to show alternative combinations for this kerning
        # This primilinary is to test how generic the groups are defined.

        if self.needsGroupKerningLinesUpdate: # Forcing the two group kerning lines to be update. Only of the main kerning sample changes.

            if gpPrev is not None and gpCurr is not None and gpNext is not None:
                ggIndex1, ggIndex2 = self._fillKerningGroupLines(km, gpPrev, gpCurr, gpNext, gpFirst.x, y)

            for n in range(ggIndex1, len(self.kerningGroupLine1)):
                self.kerningGroupLine1[ggIndex1].setVisible(False)

            for n in range(ggIndex2, len(self.kerningGroupLine2)):
                self.kerningGroupLine2[ggIndex2].setVisible(False)


    def _fillKerningGroupLines(self, km, gpPrev, gpCurr, gpNext, x, y):
        f = gpCurr.glyph.font 
        prevGroup1 = km.glyphName2GroupName1.get(gpPrev.name)
        currGroup2 = km.glyphName2GroupName2.get(gpCurr.name)
        currGroup1 = km.glyphName2GroupName1.get(gpCurr.name)
        nextGroup2 = km.glyphName2GroupName2.get(gpNext.name)

        ggIndex1 = ggIndex2 = 0

        # Reset the glyph positions for the two group lines
        self.spacerGlyphGroupPositions1 = []
        self.spacerGlyphGroupPositions2 = []

        h = f.info.unitsPerEm

        if None not in (prevGroup1, currGroup2):
            group1 = list(km.glyphName2Group1.get(gpPrev.name, []))
            group2 = list(km.glyphName2Group2.get(gpCurr.name, []))
            k = f.kerning.get((prevGroup1, currGroup2), 0)

            y -= f.info.unitsPerEm * 2
            xx = x + y * tan(radians(-(f.info.italicAngle or 0))) - 30000

            for ggIndex1 in range(0, int(len(self.kerningGroupLine1)), 2):
                gName1 = choice(group1)
                gName2 = choice(group2)
                if gName1 not in f or gName2 not in f:
                    continue
                g1 = f[gName1] 
                g2 = f[gName2]
                #print('[1]', gName1, gName2, k)

                self.spacerGlyphGroupPositions1.append(KerningLineGlyphPosition(g1, xx, y, g1.width + k, h, k, None, self.SPACER_FILL_COLOR, ggIndex1))

                kgl = self.kerningGroupLine1[ggIndex1]
                kgl.setPath(g1.getRepresentation("merz.CGPath"))
                kgl.setPosition((xx, y))
                kgl.setVisible(True)
                xx += g1.width + k

                self.spacerGlyphGroupPositions1.append(KerningLineGlyphPosition(g2, xx, y, g2.width, h, k, None, self.SPACER_FILL_COLOR, ggIndex1+1))

                kgl = self.kerningGroupLine1[ggIndex1+1]
                kgl.setPath(g2.getRepresentation("merz.CGPath"))
                kgl.setPosition((xx, y))
                kgl.setVisible(True)
                xx += g2.width + 500

        if None not in (currGroup1, nextGroup2):
            group1 = list(km.glyphName2Group1.get(gpCurr.name, []))
            group2 = list(km.glyphName2Group2.get(gpNext.name, []))
            k = f.kerning.get((currGroup1, nextGroup2), 0)

            y -= f.info.unitsPerEm * 1.4
            xx = x + y * tan(radians(-(f.info.italicAngle or 0))) - 30000

            for ggIndex2 in range(0, int(len(self.kerningGroupLine2)), 2):
                gName1 = choice(group1)
                gName2 = choice(group2)
                if gName1 not in f or gName2 not in f:
                    continue
                g1 = f[gName1] 
                g2 = f[gName2]
                #print('[2]', gName1, gName2, k)

                self.spacerGlyphGroupPositions2.append(KerningLineGlyphPosition(g1, xx, y, g1.width + k, h, k, None, self.SPACER_FILL_COLOR, ggIndex2))

                kgl = self.kerningGroupLine2[ggIndex2]
                kgl.setPath(g1.getRepresentation("merz.CGPath"))
                kgl.setPosition((xx, y))
                kgl.setVisible(True)
                xx += g1.width + k

                self.spacerGlyphGroupPositions2.append(KerningLineGlyphPosition(g2, xx, y, g2.width, h, k, None, self.SPACER_FILL_COLOR, ggIndex2+1))

                kgl = self.kerningGroupLine2[ggIndex2+1]
                kgl.setPath(g2.getRepresentation("merz.CGPath"))
                kgl.setPosition((xx, y))
                kgl.setVisible(True)
                xx += g2.width + 500

        self.needsGroupKerningLinesUpdate = True # Indicate that we just did it.

        return ggIndex1, ggIndex2


    def mouseMoveSpacer(self, g, x, y, event):
        """Set the hoover color for the current selected glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        self.selectedHoverGlyphName = None

        for gpLineIndex, glyphPositions in enumerate((self.spacerGlyphPositions, self.spacerGlyphGroupPositions1, self.spacerGlyphGroupPositions2)):

            if not glyphPositions:
                continue

            gpFirst = glyphPositions[0]
            gpLast = glyphPositions[-1]

            sy = y/self.KERN_SCALE
            offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + sy * tan(radians(-(g.font.info.italicAngle or 0)))
            sx = x/self.KERN_SCALE - offsetX


            for gIndex, gp in enumerate(glyphPositions):
                if gp.x <= sx <= gp.x + gp.w and gp.y - gp.h <= sy <= gp.y + gp.h:
                    color = self.SPACER_HOVER_COLOR
                    visible = True
                    self.selectedHoverGlyphName = gp.name # Used to open the glyph if clicked on.
                    #print(self.selectedHoverGlyphName)

                elif gp.name == g.name:
                    color = self.SPACER_SELECTED_COLOR
                    visible = False
                
                else:
                    color = self.SPACER_FILL_COLOR
                    visible = False
                        
                #self.kerningLineNames[gIndex].setFillColor(color)
                #self.kerningLineNames[gIndex].setPosition((gp.x, gp.y))
                #self.kerningLine[gIndex].setFillColor(color)
                #self.kerningLineNames[gIndex]
                #self.kerningLineNames[gIndex].setVisible(visible)
                   
    def mouseDownSpacer(self, g, x, y, evnt):
        """Open Editor window on clicked glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        sy = y/self.KERN_SCALE
        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 - sy * tan(radians(-(g.font.info.italicAngle or 0)))
        sx = x/self.KERN_SCALE - offsetX

        if self.selectedHoverGlyphName is not None: # Is there a current hover selected
            OpenGlyphWindow(glyph=g.font[self.selectedHoverGlyphName], newWindow=False)

    def updateSpacer(self, info):
        """If the checkbox is set, then try to check and fix automated margins and width.
        Answer the boolean flag if something was changed to the glyph."""
        g = info['glyph']
        if g is None:
            return False # Nothing changed.
        return self.updateSpacerKerningGlyphs(g)

    KERNING_TYPE_LABELS = {
        0: ('', (0, 0, 0, 1)), # Group-Group kerning
        1: (' (G-g)', (0.5, 0, 0.5, 1)), # Group-glyph kerning
        2: (' (G-g)', (0.5, 0.5, 0, 1)), # glyph-Group kerning
        3: (' (g-g)', (0, 0.5, 0.5, 1)), # glyph-glyph kerning
    }
    
    def updateSpacerKerningGlyphs(self, g):

        c = self.getController()
        if c is None: # The window may have been closed
            return False # Nothing happened

        km = self.getKerningManager(g.font)

        gNameLeft = km.kerningSample[max(0, km.sampleKerningIndex - 1)]
        gNameRight = km.kerningSample[min(len(km.kerningSample), km.sampleKerningIndex + 1)]

        gLeft = g.font[gNameLeft]
        gRight = g.font[gNameRight]

        kLeft, groupKLeft, kerningTypeLeft = km.getKerning(gNameLeft, g.name)
        kRight, groupKRight, kerningTypeRight = km.getKerning(g.name, gNameRight)

        # Recaclulate KernNet, since this the spacing or shape may have changed from last time
        knLeft = km.getKernNetKerning(gLeft, g) or 0
        knRight = km.getKernNetKerning(g, gRight) or 0

        #print(f'--- ({knLeft}) {kLeft} {groupKLeft} {kerningTypeLeft} <--> ({knRight}) {kRight} {groupKRight} {kerningTypeRight}')

        y1 = g.font.info.descender - 60
        y2 = y1 - 60

        if kLeft < 0:
            color = (1, 0, 0, 1)
        elif kLeft == 0:
            color = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            color = (0, 0.5, 0, 1)

        if knLeft < 0:
            knColor = (1, 0, 0, 1)
        elif knLeft == 0:
            knColor = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            knColor = (0, 0.5, 0, 1)

        kLeftTypeLabel, ktLeftColor = self.KERNING_TYPE_LABELS[kerningTypeLeft]
        kRightTypeLabel, ktRightColor = self.KERNING_TYPE_LABELS[kerningTypeRight]

        showOverlays = c.w.showKerningOverlays.get()

        self.spacerGlyphLeft.setPath(gLeft.getRepresentation("merz.CGPath"))
        self.spacerGlyphLeft.setFillColor(ktLeftColor)
        self.spacerGlyphLeft.setPosition((-gLeft.width - kLeft, 0))
        self.spacerGlyphLeft.setVisible(showOverlays)

        # Actual kerning value
        self.spacerGlyphKerningLeft.setText(str(kLeft) + kLeftTypeLabel)
        self.spacerGlyphKerningLeft.setPosition((self.italicX(g, kLeft/2, y1), y1))
        self.spacerGlyphKerningLeft.setFillColor(color)
        self.spacerGlyphKerningLeft.setVisible(showOverlays)

        # KernNet suggested kerning value
        self.spacerGlyphKernNetLeft.setText(f'*{knLeft}')
        self.spacerGlyphKernNetLeft.setPosition((self.italicX(g, kLeft/2, y2), y2))
        self.spacerGlyphKernNetLeft.setFillColor(knColor)
        self.spacerGlyphKernNetLeft.setVisible(showOverlays)

        if kRight < 0:
            color = (1, 0, 0, 1)
        elif kRight == 0:
            color = (0.5, 0.5, 0.5, 1)
        else: # kRight > 0
            color = (0, 0.5, 0, 1)

        if knRight < 0:
            knColor = (1, 0, 0, 1)
        elif knRight == 0:
            knColor = (0.5, 0.5, 0.5, 1)
        else: # kLeft > 0
            knColor = (0, 0.5, 0, 1)

        self.spacerGlyphRight.setPath(gRight.getRepresentation("merz.CGPath"))
        self.spacerGlyphRight.setFillColor(ktRightColor)
        self.spacerGlyphRight.setPosition((g.width + kRight, 0))
        self.spacerGlyphRight.setVisible(showOverlays)

        # Actual kerning value
        self.spacerGlyphKerningRight.setText(str(kRight) + kRightTypeLabel)
        self.spacerGlyphKerningRight.setPosition((self.italicX(g, g.width + kRight/2, y1), y1))
        self.spacerGlyphKerningRight.setFillColor(color)
        self.spacerGlyphKerningRight.setVisible(showOverlays)

        # KernNet suggested kerning value
        self.spacerGlyphKernNetRight.setText(f'{knRight}*')
        self.spacerGlyphKernNetRight.setPosition((self.italicX(g, g.width + kRight/2, y2), y2))
        self.spacerGlyphKernNetRight.setFillColor(knColor)
        self.spacerGlyphKernNetRight.setVisible(showOverlays)

        changed = self.checkFixGlyphSpacing(g)
        return changed

    def checkFixGlyphSpacing(self, g, updateMerz=True):
        changed = self.checkFixGlyphLeftMargin(g, updateMerz=updateMerz)
        changed |= self.checkFixGlyphRightMargin(g, updateMerz=updateMerz)
        #changed |= self.checkFixGlyphWidth(g)        
        return changed

    KEY_CENTER_GLYPH = '='
    KEY_INC_RIGHT_MARGIN_CAP = 'P'
    KEY_INC_RIGHT_MARGIN = 'p'
    KEY_DEC_RIGHT_MARGIN_CAP = 'O'
    KEY_DEC_RIGHT_MARGIN = 'o'
    KEY_INC_LEFT_MARGIN_CAP = 'I'
    KEY_INC_LEFT_MARGIN = 'i'
    KEY_DEC_LEFT_MARGIN_CAP = 'U'
    KEY_DEC_LEFT_MARGIN = 'u'

    KEY_INC_KERN2_CAP = '>'
    KEY_INC_KERN2 = '.'
    KEY_DEC_KERN2_CAP = '<'
    KEY_DEC_KERN2 = ','
    KEY_INC_KERN1_CAP = 'M'
    KEY_INC_KERN1 = 'm'
    KEY_DEC_KERN1_CAP = 'N'
    KEY_DEC_KERN1 = 'n'
    KEY_SET_KERNNET1 = '÷' # Option-/ for left kerning from KernNet
    KEY_SET_KERNNET2 = '/' # KernNet value by [/] is more default than clearing
    KEY_SET_KERN_0 = '?' # Reverse these from previous spacer version. [?] clears kerning pair

    def buildSpacer(self, y):
        """Build the assistant UI for anchor controls."""
        personalKey_eq = self.registerKeyStroke(self.KEY_CENTER_GLYPH, 'spacerCenterGlyph')

        # Incremental/decremental spacing by key

        personalKey_U = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN_CAP, 'spacerDecLeftMarginCap')
        personalKey_u = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN, 'spacerDecLeftMargin')
        personalKey_I = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN_CAP, 'spacerIncLeftMarginCap')
        personalKey_i = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN, 'spacerIncLeftMargin')

        personalKey_O = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN_CAP, 'spacerDecRightMarginCap')
        personalKey_o = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN, 'spacerDecRightMargin')
        personalKey_P = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN_CAP, 'spacerIncRightMarginCap')
        personalKey_p = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN, 'spacerIncRightMargin')

        # Incremental/decremental kerning by key

        personalKey_M = self.registerKeyStroke(self.KEY_INC_KERN1_CAP, 'spacerDecKern1Cap')
        personalKey_m = self.registerKeyStroke(self.KEY_INC_KERN1, 'spacerDecKern1')
        personalKey_N = self.registerKeyStroke(self.KEY_DEC_KERN1_CAP, 'spacerIncKern1Cap')
        personalKey_n = self.registerKeyStroke(self.KEY_DEC_KERN1, 'spacerIncKern1')

        personalKey_larger = self.registerKeyStroke(self.KEY_INC_KERN2_CAP, 'spacerIncKern2Cap')
        personalKey_period = self.registerKeyStroke(self.KEY_INC_KERN2, 'spacerIncKern2')
        personalKey_smaller = self.registerKeyStroke(self.KEY_DEC_KERN2_CAP, 'spacerDecKern2Cap')
        personalKey_comma = self.registerKeyStroke(self.KEY_DEC_KERN2, 'spacerDecKern2')

        personalKey_division = self.registerKeyStroke(self.KEY_SET_KERNNET1, 'spacerSetKernNet1')
        personalKey_question = self.registerKeyStroke(self.KEY_SET_KERNNET2, 'spacerSetKernNet2')
        personalKey_slash = self.registerKeyStroke(self.KEY_SET_KERN_0, 'spacerSetKernClear2')

        # Kerning sample selection

        personalKey_pageHome = self.registerKeyStroke(self.PAGE_HOME_FUNCTION_KEY, 'spacerPreviousKerningGlyph') # (spacerPageHome) Actual key function "Home" here used as "Left": Previous kerning pair
        personalKey_pageEnd = self.registerKeyStroke(self.PAGE_END_FUNCTION_KEY, 'spacerNextKerningGlyph') # (spacerPageEnd) Actual key function "End" here used as "Right": Next kerning pair
        personalKey_pageUp = self.registerKeyStroke(self.PAGE_UP_FUNCTION_KEY, 'spacerPreviousKerningLine') # (spacerPageUp) Actual key function "Previous page" here used as: Previous kerning line
        personalKey_pageDown = self.registerKeyStroke(self.PAGE_DOWN_FUNCTION_KEY, 'spacerNextKerningLine') # (spacerPageDown) Actual key function "Next page" here used as: Next kerning line

        c = self.getController()
        C0, C1, C2, CW, L = self.C0, self.C1, self.C2, self.CW, self.L
        LL = 18
        c.w.showKerningOverlays = CheckBox((C0, y, CW, L), 'Show kerning overlays', value=False, sizeStyle='small', callback=self.updateEditor)
        c.w.autoSpace = CheckBox((C1, y, CW, L), 'Auto space', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.centerGlyphButton = Button((C2, y, CW, L), f'Center width [{personalKey_eq}]', callback=self.spacerCenterGlyphCallback)
        y += L
        c.w.splitSimScripts = CheckBox((C0, y, CW, L), 'Split Sim scripts', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.showSpacingSampleLine = CheckBox((C1, y, CW, L), 'Show sample line', value=True, sizeStyle='small', callback=self.updateEditor)
        
        # Decrement/Increment Left Margin is imaginary pushing on the sidebearing, not on the glyph.
        c.w.incLeftMarginButton = Button((C2, y, CW/4, L), f'<[{personalKey_u}]', callback=self.spacerIncLeftMarginCallback)
        c.w.decLeftMarginButton = Button((C2+CW/4, y, CW/4, L), f'[{personalKey_i}]>', callback=self.spacerDecLeftMarginCallback)
        c.w.decRightMarginButton = Button((C2+2*CW/4, y, CW/4, L), f'<[{personalKey_o}]', callback=self.spacerDecRightMarginCallback)
        c.w.incRightMarginButton = Button((C2+3*CW/4, y, CW/4, L), f'[{personalKey_p}]>', callback=self.spacerIncRightMarginCallback)
        y += L
        c.w.spacerMode = RadioGroup((C0, y, 2*CW+12, L), ('Glyf', 'Sim', 'Group', 'Space', 'Kern'), isVertical=False, sizeStyle='small', callback=self.updateEditor)
        c.w.spacerMode.set(1)
        c.w.kerningSamplePattern1 = EditText((C2, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 1
        c.w.kerningSampleValue = EditText((C2+CW/2-18, y, 36, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning value range sample group 1
        c.w.kerningSamplePattern2 = EditText((C2+CW/2+18, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 2
        #c.w.decKern2Button = Button((C2, y, CW/4, L), '<[%s]' % personalKey_m, callback=self.spacerDecKern2Callback)
        #c.w.incKern2Button = Button((C2+CW/4, y, CW/4, L), '[%s]>' % personalKey_n, callback=self.spacerIncKern2Callback)
        #c.w.decKern1Button = Button((C2+2*CW/4, y, CW/4, L), '<[%s]' % personalKey_period, callback=self.spacerDecKern1Callback)
        #c.w.incKern1Button = Button((C2+3*CW/4, y, CW/4, L), '[%s]>' % personalKey_comma, callback=self.spacerIncKern1Callback)
        y += L
        c.w.autoSpaceAllButton = Button((C0, y, CW, L), 'Auto space all', callback=self.autoSpaceAllCallback)
        c.w.fixReportedSpacingDifferences = CheckBox((C1, y, CW, L), 'Fix reported', value=False, sizeStyle='small')
        c.w.reportSpacingButton = Button((C2, y, CW, L), 'Report spacing', callback=self.reportSpacingCallback)
        y += L + 10
        c.w.autoSpaceFontButton = Button((C0, y, CW, L), 'Auto space font', callback=self.autoSpaceFontCallback)
        c.w.fixOverlappedKerningButton = Button((C1, y, CW, L), 'Fix overlapped kerns', callback=self.fixOverlappedKerningCallback)
        c.w.autoSpaceAllTheseGlyphsButton = Button((C2, y, CW, L), 'Fix all these glyphs', callback=self.autoSpaceAllTheseGlyphsCallback)
        y += L + 10
        c.w.selectKerningByCharPair = CheckBox((C0, y, CW, L), 'By char kerning pair', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.charKerningPairTextBox = EditText((C1, y, CW, L), callback=self.updateEditor)
        c.w.charKerningPairTextBox.set('AA')
        # Not much autoKernNet for now: make it more reliable first
        #c.w.factorKernNetTextBox = EditText((C0, y, 48, L))
        #c.w.factorKernNetTextBox.set('1.2')
        #c.w.calibrateKernNetTextBox = EditText((C1, y, 48, L))
        #c.w.calibrateKernNetTextBox.set('0')
        #c.w.autoKernAllGroupsButton = Button((C2, y, CW, L), 'Auto kern groups', callback=self.autoKernGroupsCallback)
        #c.w.autoKernAllGroupsButton.enable(False)
        #y += L + 10
        #c.w.initilalizeAllScriptScriptKerningButton = Button((C2, y, CW, L), 'Initialize all scripts', callback=self.initilalizeAllScriptScriptKerningCallback)
        y += L + 10
        c.w.spacerEndLine = HorizontalLine((self.M, y, -self.M, 1))
        c.w.spacerEndLine2 = HorizontalLine((self.M, y, -self.M, 1))
        y += L/5

        return y

    def initilalizeAllScriptScriptKerningCallback(self, sender):
        """Make sure that all script <--> script kerning combinations have at least one placeholder kerning pair."""
        for f in self.getAllFonts():
            km = self.getKerningManager(f)
            km.initializeKernGroups()

    def makeKerningSampleCallback(self, sender):
        """One of the kerning sample filters changed, let de kerning manager make a new kerning sample."""
        c = self.getController()
        g = self.getCurrentGlyph()
        km = self.getKerningManager(g.font)
        km.kerningSampleFilter1 = c.w.kerningSamplePattern1.get() or None
        km.kerningSampleValue = int(c.w.kerningSampleValue.get() or 0) or None
        km.kerningSampleFilter2 = c.w.kerningSamplePattern2.get() or None

        g.changed()

    def autoSpaceAllCallback(self, sender):
        """Auto space all UFO's in the family, recursively applying all rules until that base glyph. Keep track of the glyphs 
        that were modified to avoid double work. Report on the glypns that got changed."""
        print('--- Auto spacing all masters')
        f = self.getCurrentFont()
        parentPath = self.filePath2ParentPath(f.path)

        for pth in self.getUfoPaths(parentPath):
            f = self.getFont(pth)
            print(f'... Auto spacing {f.path.split("/")[-1]}')
            for g in f: # First check all glyphs without components
                if g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            for g in f: # Then check all glyphs with components
                if not g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            # Watch out: this will auto-save the adjusted font
            f.save()

    def autoSpaceAllTheseGlyphsCallback(self, sender):
        """Auto space this glyph in all masters."""
        g = self.getCurrentGlyph()
        parentPath = self.filePath2ParentPath(g.font.path)

        for pth in self.getUfoPaths(parentPath):
            f = self.getFont(pth)
            #print(f'... Fix spacing {f.path.split("/")[-1]} /{g.name}')
            if g.name in f:
                gg = f[g.name]
                changed = self.checkFixGlyphSpacing(gg, updateMerz=False) # Only print what it did if there was a change.
                if changed:
                    gg.changed()

    def autoSpaceFontCallback(self, sender):
        """Auto space the current font, recursively applying all rules until that base glyph. Keep track of the glyphs 
        that were modified to avoid double work. Report on the glypns that got changed."""
        print('--- Auto spacing current master')
        f = self.getCurrentFont()
        print(f'... Auto spacing {f.path.split("/")[-1]}')
        for g in f: # First check all glyphs without components
            if g.components:
                continue
            changed = self.checkFixGlyphSpacing(g, updateMerz=False)
            if changed:
                g.changed()
        for g in f: # Then check all glyphs with components
            if not g.components:
                continue
            changed = self.checkFixGlyphSpacing(g, updateMerz=False)
            if changed:
                g.changed()
        # Watch out: this will auto-save the adjusted font
        f.save()

    def autoKernGroupsCallback(self, sender):
        """Auto kern all groups and kerning pairs for the given template for all UFO's in the family.
        Report on the groups and pairs that got changed. Only perform real changes if the safety switch is enabled."""
        print('--- Auto kern all masters')
        f = self.getCurrentFont()
        km = self.getKerningManager(f)
        try:
            factor = float(self.w.factorKernNetTextBox.get())
        except ValueError:
            factor = 1
        try:
            calibrate = int(self.w.calibrateKernNetTextBox.get())
        except ValueError:
            calibrate = 0
        km.kernGroups(factor=factor, calibrate=calibrate, verbose=True)

    def fixOverlappedKerningCallback(self, sender):
        """Scan through all possible kerning pairs (groups x group) as defined in the allowed script combinations.
        """
        print('... fixOverlappedKerningCallback')
        # Alway update the list of kerningTypes. This is an "expensive" operation, so we cache.
        # It's mostly to get an impressions how the kerning types are distributed in the f.kerning.
        # For a better view on the amounts an update should be done, or we need to do some bookkeeping outselves.
        # kerningTypes is a tuple of 5 kerning dictionaries where the types are split according
        # (group-group, group-glyph, glyph-group, glyph-glyph and bad). The bad dictionary is all kerning pairs
        # that refer to non-existing groups or non-existing glyphs. In principle it always should be empty,
        # otherwise kerning table needs to be cleaned up. 
        
        f = self.getCurrentFont()
        if f is None:
            return

        md = self.getMasterData(f)

        # Only check for overlap on kerning for these glyphs
        checkedGlyphs = set((
            'E', 'K', 'V', 'T', 'V', 'W', 'X', 'Y', 'Z', 'AE', 'OE',  
            'backslash', 'braceleft', 'braceright', 'bracketleft', 'bracketright', 
            'acircumflexgrave', 'acircumflexhookabove', 'adblgrave', 
            'cacute', 'ccaron', 'ccircumflex', 
            'd', 'dcaron', 'dcedilla', 'ddotaccent', 'ddotbelow', 
            'edblgrave', 'edieresis', 'etilde', 

            'i', 'igrave', 'iacute', 'icircumflex', 'idieresis', 'itilde', 'imacron', 'ibreve', 'iogonek', 'icaron', 'idblgrave', 
                'iinvertedbreve', 'itildebelow', 'idieresisacute', 'ihookabove', 'idotbelow', 'idotless', 'ij', 'istroke', 
                'iota', 'iotadieresistonos', 'iotatonos', 'iotadieresis', 'idotlesshorn'
            'jcaron', 'jcircumflex', 
            'ocircumflexacute', 'ocircumflexgrave', 'ocircumflexhookabove', 'odblgrave', 
            'one', 'question', 'lcaron', 'scaron', 'scircumflex',
            'racute', 'rcaron', 'rdblgrave', 'rinvertedbreve', 
            'parenleft', 'parenright', 'percent', 'perthousand',  
            'seven', 'slash', 'tcaron', 'three', 'trademark', 'two', 'uhorn',
        ))
        # Not checked for overlapping kerning combinations, avoiding a huge load of permutated exceptions that are hardly used
        UNCHECKED = set((
            'Tbar', 'Tcaron', 'Tcedilla', 'Tcommaaccent', 'Tdiagonalstroke', 'Tdotaccent', 'Tdotbelow', 'Thook', 'Tz', 
            'Vdiagonalstroke', 'Vdotbelow', 'Vtilde', 
            'AEacute', 'AEmacron', 'AY', 'Aturned', 'Au', 'Av', 
            'Bhook', 'degree', 'dhook', 'dtopbar', 'eshbaseline',
            'Chi-latin', 'Cstroke', 'Dhook', 
            'Eacute', 'Ebreve', 'Ecaron', 'Ecedilla', 'Ecedillabreve', 'Ecircumflex', 'Ecircumflexacute', 'Ecircumflexdotbelow', 'Ecircumflexgrave', 'Ecircumflexhookabove', 'Ecircumflextilde', 'Edblgrave', 'Edieresis', 'Edotaccent', 'Edotbelow', 'Egrave', 'Ehookabove', 'Einvertedbreve', 'Emacron', 'Emacronacute', 'Emacrongrave', 'Estroke', 'Etilde', 
            'Gammaafrican', 'Ghook', 'iinvertedbreve',
            'Idblgrave', 'Itilde', 'product',
            'Kacute', 'Kcaron', 'Kcommaaccent', 'Kdotbelow', 'Khook', 'Klinebelow', 'Kstroke', 
            'Lcaron', 
            'Pflourish', 'Phook', 
            'Xdieresis', 'Xdotaccent', 
            'Yacute', 'Ycircumflex', 'Ydieresis', 'Ydotaccent', 'Ydotbelow', 'Ygrave', 'Yhook', 'Yhookabove', 'Ymacron', 'Ystroke', 'Ytilde', 
            'bstroke', 
            'kstroke',  
            'lhighstroke', 'longs', 'longsdotaccent', 
            'qhook', 
            'hbar', 
            'rlonglegturned',  
            'tesh', 'thook', 'thornstroke', 'turnedrtail', 
            'ohorn', 'ohornacute', 'ohorndotbelow', 'ohorngrave', 'ohornhookabove', 'ohorntilde', 
            'uhornacute', 'uhorndotbelow', 'uhorngrave', 'uhornhookabove', 'uhorntilde', 'uniA7AE'))

        # Result of checked combinations for Segoe Black Italic
        # ốV ổV ốř ốȑ ổȑ ốT ổT ốồ ốȅ ốȍ ốȁ ốầ ổồ ổȅ ổầ ốǐ ốì ốȉ ốĭ ốï ổǐ ổì ổȉ ổĭ ổï ốǰ ổǰ ốW ổW ốY ổY ḯi ïV ḯV ïȑ ḯȑ ïT ḯT ïồ ḯồ ḯầ ïǐ ïì ïȉ ïĭ ïï ïĩ ïî ïī ḯǐ ḯì ḯȉ ḯĭ ḯï ḯĩ ḯî ḯī ïǰ ïĵ ḯǰ ḯĵ ḯŝ ḯW ïĳ ïį ḯĳ ḯį ïY ḯY ẽȉ ëY ẽY íȑ ǐř ǐȑ íồ íȅ íȍ íầ ǐồ ǐȅ ǐȍ ǐȁ ǐầ íǐ íì íȉ íĭ íï ǐǐ ǐì ǐȉ ǐĭ ǐï ȉȉ ȉï ȉĩ ȉî ȉī īȉ īĭ īï īĩ īî īī íǰ ǐǰ ȉĵ īĵ ưȑ ưȉ ưï ưĩ ưî ưĵ ưŝ šȑ ŝT šồ šầ šǐ šì šȉ ŝî šǰ ŝĵ šY įǰ įĵ ďř ďȑ ďȓ ľř ľȑ ľȓ ľX ďč ďồ ďȅ ďȍ ďë ďḋ ďȁ ďầ ľč ľồ ľȅ ľȍ ľë ľḋ ľȁ ľầ ďì ďȉ ďĭ ľǐ ľì ľȉ ľĭ ľï ďǰ ďĵ ľǰ ľĵ ďš ďŝ ľš ľŝ ľÆ ďĳ ďį ľĳ ľį Æȉ Æï Eȉ Eï Œȉ Œï Vȑ Vồ Vầ Vȉ Vĭ Vï Vĩ Kȑ Kồ Kầ Kȉ Kĭ Kï Kǰ Yȑ Yồ Yȅ Yȍ Yȁ Yầ Yȉ Yǰ Yĵ YW Yĳ Yį ťȑ ťồ ťầ ťǐ ťì ťȉ ťĭ ťï ťǰ ŕť řť ȑť ȓť ŕȑ řȑ ŕồ ŕầ řồ řầ ŕǐ ŕì ŕȉ řǐ řì řȉ řĭ ȑî ȓȉ ȓï ȓĩ ȓî ŕǰ řǰ ȑĵ ȓĵ řY Wȑ Wồ Wȉ Wï Wĵ Xȑ Xồ Xầ Xȉ Xĭ Xï Xĩ Xǰ dȑ ḑȑ ḋȑ ḍȑ dồ ḑồ ḋồ ḍồ dì dȉ dĭ dï dĩ dî ḑì ḑȉ ḑĭ ḑï ḑĩ ḑî ḋì ḋȉ ḋĭ ḋï ḋĩ ḋî ḍì ḍȉ ḍĭ ḍï ḍĩ ḍî dĵ ḑĵ ḋĵ ḍĵ ǰV ĵV ǰř ǰȑ ĵT ǰồ ǰȅ ǰȍ ǰȁ ǰầ ĳȉ ĳï ǰǐ ǰì ǰȉ ǰĭ ǰï ǰĩ ĵȉ ĵï ĵĩ ĵî ĵī ǰǰ ĵĵ Tȑ Tồ Tầ Tȉ Tĵ ćȑ čȑ ćồ čồ čầ ćì ćȉ čǐ čì čȉ ĉĩ ĉî čǰ ĉĵ ẩȑ ẩT ẩồ ẩȅ ẩȍ ẩầ ẩǐ ẩì ẩȉ ẩĭ ẩï ẩǰ ẩY ĭȑ ĩȑ îT ĭồ ĭầ ĩồ ĩầ ĭǐ ĭì ĭȉ ĭĭ ĭï ĭĩ ĭī îȉ îï îĩ îî îī ĩǐ ĩì ĩȉ ĩĭ ĩï ĩĩ ĩî ĩī ĭǰ îĵ ĩǰ ĩĵ 1ȉ 7ȑ 7ồ 7ȉ 7ĭ 7ï 7ĩ 7î 7ĵ ố7 ï1 ḯ1 ï2 ḯ3 ḯ2 ï7 ḯ7 ȉ1 ī1 ư1 ĵ1 ĵ3 ĵ2 ĵ7 î1 î2 ]ȉ ™ȉ (ȑ [ȑ (ồ (ȅ (ầ {ồ [ồ [ȅ [ầ (ȉ (ĭ (ï {ȉ {ï [ì [ȉ [ĭ [ï [ĩ [î [ī (ǰ (ĵ {ǰ {ĵ [ǰ [ĵ (ĳ (į [ĳ [į /V /ȑ /T /ồ /ȅ /ȍ /ầ /ǐ /ì /ȉ /ĭ /ï /ĩ /î /ī /ǰ /ĵ /W /Y ố\ ổ\ ố™ ổ™ ï\ ḯ\ ï™ ḯ™ ï? ḯ? ï] ḯ} ḯ] ï% ï‰ ḯ% ḯ‰ ë\ ẽ\ í\ ǐ\ ī\ í™ ǐ™ ȉ™ ī™ ȉ? ī? ư? ư] š\ ŝ\ ŝ? i\ į\ i™ į™ ď\ ľ\ V\ K\ Y\ ť\ ŕ% ŕ‰ ř% ř‰ ȑ% ȑ‰ ȓ% ȓ‰ W\ X\ ǰ\ ĵ\ ĵ? ĵ] ĵ% ĵ‰ ĉ? ẩ\ ĭ\ î\ ĩ\ î? î% î‰ 
        # ['AE', 'E', 'K', 'OE', 'T', 'V', 'W', 'X', 'Y', 'acircumflexgrave', 'acircumflexhookabove', 'adblgrave', 'backslash', 'braceleft', 'braceright', 'bracketleft', 'bracketright', 'cacute', 'ccaron', 'ccircumflex', 'd', 'dcaron', 'dcedilla', 'ddotaccent', 'ddotbelow', 'edblgrave', 'edieresis', 'etilde', 'i', 'iacute', 'ibreve', 'icaron', 'icircumflex', 'idblgrave', 'idieresis', 'idieresisacute', 'igrave', 'ij', 'imacron', 'iogonek', 'itilde', 'jcaron', 'jcircumflex', 'lcaron', 'ocircumflexacute', 'ocircumflexgrave', 'ocircumflexhookabove', 'odblgrave', 'one', 'parenleft', 'parenright', 'percent', 'perthousand', 'question', 'racute', 'rcaron', 'rdblgrave', 'rinvertedbreve', 'scaron', 'scircumflex', 'seven', 'slash', 'tcaron', 'three', 'trademark', 'two', 'uhorn']
        
        done = False
        minOffset = 64 # Value to add to touching-kerning for minimal distance
        minOverlapOffset = 32 # Only take action if distant is less than this.

        fixedOverlap = ''
        errorOverlap = ''
        errorNames = set()
        errorExceptions = set()

        km = self.getKerningManager(f)
        km.clearGlyphGlyphKerning() # Clear all glyph-glyph kerning, probably generated by a previous run.
        km.clearGroupGlyphKerning() # Clear all Group-glyph kerning, probably generated by a previous run.
        km.clearGlyphGroupKerning() # Clear all Group-glyph kerning, probably generated by a previous run.

        #self.kerningTypes = km.splitKerningTypes()
        for script1, script2 in KERN_GROUPS:
            mg1 = km.scriptMatchingGroups1[script1]
            mg2 = km.scriptMatchingGroups2[script2]
            #print(mg1, mg2)
            for groupName1 in mg1:
                for groupName2 in mg2:
                    group1 = f.groups[groupName1]
                    group2 = f.groups[groupName2]
                    for gName1 in group1:
                        g1 = f[gName1]
                        gd1 = self.getGlyphData(g1)
                        for gName2 in group2:
                            #if gName1 in errorNames and gName2 in errorNames:
                            #    continue
                            #if gName1 in errorExceptions and gName2 in errorExceptions:
                            #    continue
                            if gName1 in checkedGlyphs and gName2 in checkedGlyphs: # Only these combinations
                                g2 = f[gName2]
                                gd2 = self.getGlyphData(g2)
                                #print(gName1, gName2, km.hasKernedOverlap(g1, g2, minOffset))
                                if km.hasKernedOverlap(g1, g2, minOverlapOffset): # minOffset forces a minimal gap for the overlap
                                    #if gName1 != 'Tcaron' or gName2 != 'idieresis':
                                    #    continue
                                    kk = int(round(km.kernedDistance(g1, g2) / 4)) * 4
                                    if abs(-kk + minOffset) < 1000: # Safety, in case the overlap is not matching
                                        if gd1.isLower:
                                            kern1 = gName1 # g-x
                                        else:
                                            kern1 = groupName1 # G-x
                                        if gd2.isLower:
                                            kern2 = gName2 # x-g
                                        else:
                                            kern2 = groupName2 # x-G
                                        if (kern1, kern2) not in f.kerning: 
                                            print('... Fix overlap', kk, -kk + minOffset, script1, script2, groupName1, groupName2, kern1, kern2)
                                            f.kerning[(kern1, kern2)] = -kk + minOffset
                                            if g1.unicode and g2.unicode:
                                                fixedOverlap += chr(g1.unicode) + chr(g2.unicode) + ' '
                                    else:
                                        print('### Error overlap', kk, -kk + minOffset, script1, script2, groupName1, groupName2, gName1, gName2)
                                        if g1.unicode and g2.unicode:
                                            errorOverlap += chr(g1.unicode) + chr(g2.unicode) + ' '
                                            errorNames.add(gName1)
                                            errorNames.add(gName2)
                                else:
                                    #print('### Overlap of exception', gName1, gName2)
                                    errorExceptions.add(gName1)
                                    errorExceptions.add(gName2)
                                #    #f.kerning[(groupName1, gName2)] = 0
                                #    break
                                #print('Kerning', groupName1, gName2, f.kerning[(groupName1, gName2)])

        if errorOverlap or errorNames or errorExceptions:
            print('### Could not fix overlap for', errorOverlap)
            print('### Fixed overlap', fixedOverlap)
            print(sorted(errorNames))
            print(sorted(errorExceptions))

        # Now remove the TMP* glyphs again
        if 1:
            for gName in f.keys():
                if gName.startswith('TMP'):
                    f.removeGlyph(gName)

    def reportSpacingCallback(self, sender):
        """Report/fix margins for the current font that don't fit the epexted value as it would have been auto spaced.
        This method both allowed to get feedback on how accurate the autospacer works. And it gives a list of glyphs
        that need extra attention."""
        f = self.getCurrentFont()
        changed = self.reportSpacing(self, f)
        if changed:
            f.changed()

    def reportSpacing(self, f, doFix=False):
        changed = False
        c = self.getController()
        md = self.getMasterData(f)
        km = self.getKerningManager(f)

        # First check all glyphs without component
        for g in f:
            if g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        # Then check all glyphs with components
        for g in f:
            if not g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        return changed

    def spacerDecLeftMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustLeftMarginByUnits(g, -1)
            g.changed()

    def spacerIncLeftMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustLeftMarginByUnits(g, 1)
            g.changed()

    def spacerDecRightMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustRightMarginByUnits(g, -1)
            g.changed()

    def spacerIncRightMarginCallback(self, sender):
        g = self.getCurrentGlyph()
        if g is not None:
            self._adjustRightMarginByUnits(g, 1)
            g.changed()


    def spacerDecLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -5)
        g.changed()

    def spacerDecLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 5)
        g.changed()

    def spacerIncLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, -5)
        g.changed()

    def spacerDecRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, 5)
        g.changed()

    def spacerIncRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()

    #   K E R N I N G  K E Y S

    """
    def spacerDecKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()

    """

    def spacerDecKern2Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, -5, capLock=capLock)

    def spacerDecKern2(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, -1, capLock=capLock)

    def spacerIncKern2Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, 5, capLock=capLock)

    def spacerIncKern2(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustRightKerning(g, 1, capLock=capLock)

    def spacerDecKern1Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, -5, capLock=capLock)

    def spacerDecKern1(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, -1, capLock=capLock)

    def spacerIncKern1Cap(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, 5, capLock=capLock)

    def spacerIncKern1(self, g, c, event):
        capLock = event['capLockDown'] # Used to determine the type of kerning to apply.
        self._adjustLeftKerning(g, 1, capLock=capLock)
    
    def spacerSetKernNet1(self, g, c, event):
        """Set the left kerning value to the calculated KernNet kerning value."""
        km = self.getKerningManager(g.font)
        kernGlyphName1 = km.kerningSample[km.sampleKerningIndex]
        knLeft = km.getKernNetKerning(g, g.font[kernGlyphName1]) or 0 # Needs glyphs, not glyph names
        self._adjustLeftKerning(g, newK=knLeft)

    def spacerSetKernNet2(self, g, c, event):
        """Set the right kerning value to the calculated KernNet kerning value.
        Clear any non Group-Group kerning that may exist"""
        km = self.getKerningManager(g.font)
        kernGlyphName2 = km.kerningSample[km.sampleKerningIndex + 1]
        km.clearOtherKerningTypes(g.name, kernGlyphName2)
        knRight = km.getKernNetKerning(g, g.font[kernGlyphName2]) or 0 # Needs glyphs, not glyph names
        self._adjustRightKerning(g, newK=knRight)

    def spacerSetKernClear2(self, g, c, event):
        """Clear the right kerning value"""
        self._adjustRightKerning(g, newK=0)

    #   S A M P L E  K E Y S

    def spacerPreviousKerningLine(self, g, c, event):
        km = self.getKerningManager(g.font)
        dec = len(self.kerningLine)
        if event['shiftDown']:
            dec *= 10
            if event['optionDown']:
                dec *= 10
        
        km.sampleKerningIndex = km.sampleKerningIndex - dec # km property will take care boundaries
        prevGlyphName = km.kerningSample[km.sampleKerningIndex]
        if prevGlyphName in g.font:
            prevGlyph = g.font[prevGlyphName]
            self.openGlyphWindow(prevGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(prevGlyph)
            self.updateMerzSpacerKerningLine(prevGlyph)
        else:
            print(f'### spacerPreviousKerningLine: Cannot find {prevGlyphName}')

    def spacerNextKerningLine(self, g, c, event):
        km = self.getKerningManager(g.font)
        inc = len(self.kerningLine) # Go to next kerning line
        if event['shiftDown']:
            inc *= 10
            if event['optionDown']:
                inc *= 10

        km.sampleKerningIndex = km.sampleKerningIndex + inc # km property will take care of boundaries
        nextGlyphName = km.kerningSample[km.sampleKerningIndex]
        if nextGlyphName in g.font:
            nextGlyph = g.font[nextGlyphName]
            self.openGlyphWindow(nextGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(nextGlyph)
            self.updateMerzSpacerKerningLine(nextGlyph)
        else:
            print(f'### spacerNextKerningLine: Cannot find {nextGlyphName}')

    def spacerPreviousKerningGlyph(self, g, c, event):
        km = self.getKerningManager(g.font)
        if event['optionDown']:
            dec = 1 # Next is previous glyph, instead of skipping 2
        elif event['shiftDown']:
            dec = 10 # Skip a chunk
        else: # Previous is 2, to skip the pair
            dec = 2

        kerningSample = km.kerningSample
        km.sampleKerningIndex = km.sampleKerningIndex - dec # km property will take care of boundaries
        prevGlyphName = kerningSample[km.sampleKerningIndex]
        if prevGlyphName in g.font:
            prevGlyph = g.font[prevGlyphName]
            self.openGlyphWindow(prevGlyph, newWindow=False)
            self.updateSpacerKerningGlyphs(prevGlyph)
            self.updateMerzSpacerKerningLine(prevGlyph)
        else:
            print(f'### spacerPreviousKerningGlyph: Cannot find {prevGlyphName}')

    def spacerNextKerningGlyph(self, g, c, event):
        km = self.getKerningManager(g.font)
        if event['optionDown']:
            inc = 1 # Next is next glyph, instead of skipping 2
        elif event['shiftDown']:
            inc = 10 # Skip a chunk
        else: # Next is 2, to skip the pair
            inc = 2

        kerningSample = km.kerningSample
        km.sampleKerningIndex = km.sampleKerningIndex + inc # km property will take care of boundaries
        if km.sampleKerningIndex < len(kerningSample):
            nextGlyphName = kerningSample[km.sampleKerningIndex]
            if nextGlyphName in g.font:
                nextGlyph = g.font[nextGlyphName]
                self.openGlyphWindow(nextGlyph, newWindow=False)
                self.updateSpacerKerningGlyphs(nextGlyph)
                self.updateMerzSpacerKerningLine(nextGlyph)
            else:
                print(f'### spacerNextKerningGlyph: Cannot find {nextGlyphName}')

    #   A D J U S T  S P A C I N G

    SPACING_UNIT = KERNING_UNIT = 4

    def _adjustLeftMarginByUnits(self, g, value): 
        #if self.isUpdating:
        #    return
        f = g.font        
        g.angledLeftMargin = int(round(g.angledLeftMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT
                          
    def _adjustRightMarginByUnits(self, g, value): # This moved to TYPETR-Assistants/KerningAssistant-005.py
        #if self.isUpdating:
        #    return
        f = g.font
        g.angledRightMargin = int(round(g.angledRightMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT

    """
        #    K E R N I N G

        elif characters in '.>': # Increment right kerning
            if shiftDown:
                self._adjustRightKerning(g, 5) # 20
            else:
                self._adjustRightKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in ',<': # Decrement right kerning
            if shiftDown:
                self._adjustRightKerning(g, -5) # 20
            else:
                self._adjustRightKerning(g, -1) # 4
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Mm': # Decrement left kerning
            if shiftDown:
                self._adjustLeftKerning(g, -5) # 20
            else:
                self._adjustLeftKerning(g, -1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Nn': # Increment left kerning
            if shiftDown:
                self._adjustLeftKerning(g, 5) # 20
            else:
                self._adjustLeftKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        """

    def _adjustLeftKerning(self, g, value=None, newK=None, capLock=False):
        """ 
        Two ways of usage:
        • value is relative adjustment
        • newK is setting new kerning value.
           
            3 = glyph<-->glyph # Not used
            2 = group<-->glyph
            1 = glyph<-->group
            0 or None = group<-->group
        """
        assert value is not None or newK is not None
        f = g.font
        km = self.getKerningManager(f)
        kernGlyphName1 = km.kerningSample[km.sampleKerningIndex - 1]
        k, groupK, kerningType = km.getKerning(kernGlyphName1, g.name)
        if newK is not None:
            k = newK # Set this value, probably predicted.
        else: # Adjust relative by rounded value
            k = int(round(k/self.KERNING_UNIT))*self.KERNING_UNIT + value * self.KERNING_UNIT
        if not kerningType and capLock:
            kerningType = 2 # group<-->glyph
        elif kerningType == 2 and capLock:
            kerningType = 3 # glyph<-->glyph 
        changed = km.setKerning(kernGlyphName1, g.name, k, kerningType)
        if changed:
            print(f'... Kerning left changed to {k}')
            f.changed()
            #g.width += 1
            #g.width -= 1 # Seems to be necessarfy to force glyph change update.
            #g.glyphChangedUpdate() Does not work?
            #g.changed()
            # Does not seem to work through g.changed. Call directly to update Merz objects.
            self.updateSpacerKerningGlyphs(g)
            self.updateMerzSpacerKerningLine(g)

    def _adjustRightKerning(self, g, value=None, newK=None, capLock=False):
        """    
        Two ways of usage:
        • value is relative adjustment
        • newK is setting new kerning value.

            3 = glyph<-->glyph # Not used
            2 = group<-->glyph
            1 = glyph<-->group
            0 or None = group<-->group
        """
        assert value is not None or newK is not None
        f = g.font
        km = self.getKerningManager(f)
        unit = 4
        kernGlyphName2 = km.kerningSample[km.sampleKerningIndex + 1]
        k, groupK, kerningType = km.getKerning(g.name, kernGlyphName2)
        if newK is not None:
            k = newK # Set this value, probably predicted.
        else: # Adjust relative by rounded value
            k = int(round(k/self.KERNING_UNIT))*self.KERNING_UNIT + value * self.KERNING_UNIT
        if not kerningType and capLock:
            kerningType = 1 # glyph<-->group
        elif kerningType == 1 and capLock:
            kerningType = 3 # glyph<-->glyph
        changed = km.setKerning(g.name, kernGlyphName2, k, kerningType)
        if changed:
            print(f'... Kerning right changed to {k}')
            f.changed()
            #g.width += 1
            #g.width -= 1 # Seems to be necessarfy to force glyph change update.
            #g.glyphChangedUpdate() Does not work?
            #g.changed()
            # Does not seem to work through g.changed. Call directly to update Merz objects.
            self.updateSpacerKerningGlyphs(g)
            self.updateMerzSpacerKerningLine(g)

    #   G U E S S  S P A C I N G  &  K E R N I N G

    def checkFixGlyphWidth(self, g, km=None):
        """Use the KerningManager for the current font to determine the best width for this glyph.
        Check if this glyph should have its width altered. If it has components, then fix those first.
        If something changed, then answer True. 
        """
        changed = False
        if km is None:
            km = self.getKerningManager(g.font)

        label = ''
        color = 0, 0, 0, 0
    
        width = km.getWidth(g)
        if width is not None:
            changed = self._fixGlyphWidth(g, width)
            label = f'Width={g.width}' 
            color = self.SPACER_FIXED_WIDTH_MARKER_COLOR

        self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
        self.fixedSpaceMarkerRight.setFillColor(color)
        self.fixedSpaceMarkerRight.setVisible(True)

        self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*4))
        self.rightSpaceSourceLabel.setText(label)
        self.rightSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphLeftMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best left margin for this glyph.
        Check if this glyph should have its left margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        if c is None: # The window may have been closed
            return False # Nothing happened

        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        md = self.getMasterData(g.font)
        gd = md.glyphSet[g.name]

        if c.w.autoSpace.get() and gd is not None and gd.autoFixMargins:
            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphLeftMargin: Cannot find GlyphData for /{g.name}')
            
            elif gd.l == 'off':
                label = f'Auto-spacing is off'
                #print(f'... checkFixGlyphLeftMargin: /{g.name} auto-spacing is off')

            # First check if there is a masterData spacing source defined, that overwrites all other spacing rules
            elif md.spacingSrcUFOPath is not None and gd.w not in (0, None):  # Only if defined and the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    lm = src[g.name].angledLeftMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledLeftMargin))}+{md.spacingOffset}={int(round(lm))}'
                    changed = km.fixLeftMargin(g, lm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.leftMargin is None: # Empty glyph, can't set left/right margin
                pass

            else: # Otherwise 
                referenceLabel = gd.leftSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixLeftMarginByGlyphSetReference(g) # Fix the left margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledLeftMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else: # Strategy #2, see if there is a similar glyph to copy the left margin from.
                    similarName2 = km.getSimilarBaseName2(g)
                    if similarName2 is not None:
                        srcG2 = g.font[similarName2]
                        if similarName2 == g.name:
                            label = f'Sim base /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixLeftMargin(g, srcG2.angledLeftMargin, label)
                    else:
                        label = f'{int(round(g.angledLeftMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledLeftMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5

        if updateMerz:
            self.fixedSpaceMarkerLeft.setPosition((-self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerLeft.setFillColor(fillColor)
            self.fixedSpaceMarkerLeft.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerLeft.setVisible(True)

            self.leftSpaceSourceLabel.setPosition((0, -self.SPACER_MARKER_R*2))
            self.leftSpaceSourceLabel.setText(label)
            self.leftSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphRightMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best right margin for this glyph. 
        Check if this glyph should have its right margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        if c is None: # Window may have been closed already
            return changed

        md = self.getMasterData(g.font)
        gd = md.glyphSet[g.name]
        if gd is None:
            print(f'### checkFixGlyphRightMargin: Cannot find GlyphData for /{g.name}')
            label = ''

        elif c.w.autoSpace.get() and gd.autoFixMargins:

            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphRightMargin: Cannot find GlyphData for /{g.name}')

            elif isinstance(gd.w, (int, float)):
                w = int(round(gd.w))
                if g.width != w:
                    g.width = w
                    print(f'... Set width of /{g.name} to {w}')
                    changed = True

            elif gd.w == 'tab':

                if g.width != md.tabWidth:
                    g.width = md.tabWidth
                    print(f'Set tab width of /{g.name} to {md.tabWidth}')
                    changed = True

            elif gd.r == 'off':
                label = f'Auto-spacing is off'
                #print(f'... checkFixGlyphRightMargin: /{g.name} auto-spacing is off')

            elif md.spacingSrcUFOPath is not None and gd.w and g.width: # Only if defined and if the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    rm = src[g.name].angledRightMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledRightMargin))}+{md.spacingOffset}={int(round(rm))}'
                    changed = km.fixRightMargin(g, rm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.rightMargin is None: # Empty glyph, can't set left/right margin
                pass

            else:
                referenceLabel = gd.rightSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixRightMarginByGlyphSetReference(g) # Fix the right margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledRightMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else:
                    similarName1 = km.getSimilarBaseName1(g)
                    if similarName1 is not None:
                        srcG1 = g.font[similarName1]
                        if similarName1 == g.name:
                            label = f'Sim base /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixRightMargin(g, srcG1.angledRightMargin, label)
                    else:
                        label = f'{int(round(g.angledRightMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledRightMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5
        label += f'\n(w={g.width})'

        if updateMerz:
            self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerRight.setFillColor(fillColor)
            self.fixedSpaceMarkerRight.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerRight.setVisible(True)
            
            self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*2))
            self.rightSpaceSourceLabel.setText(label)
            self.rightSpaceSourceLabel.setVisible(True)

        return changed
    
    def spacerCenterGlyphCallback(self, sender):
        """Callback from button. Center the current glyph on its width, if not done autmatically."""
        g = self.getCurrentGlyph()
        if g is not None:
            if self.spacerCenterGlyph(g):
                g.changed()

    def spacerCenterGlyph(self, g, c=None, event=None):     
        """Snap the selected points of the current glyph onto points that are within range on the background glyph."""
        changed = False
        lm = g.angledLeftMargin
        rm = g.angledRightMargin
        w = g.width
        if lm is not None:
            g.angledLeftMargin = (lm + rm)/2
            g.width = w
            changed = True

        return changed
