# -*- coding: UTF-8 -*-
# ------------------------------------------------------------------------------
#     Copyright (c) 2023+ TYPETR
#     Usage by MIT License
# ..............................................................................
#
#   spacer.py
#
#   TODO
#   - Auto sim spacing
#   - Sample line or buttons line for alternative spacing masters
#   - Kerning line
#   - Spacing and kerning keys
#   - Set Similarity zones
#
import sys
from math import *
from vanilla import *
from AppKit import *

from mojo.UI import OpenGlyphWindow
from mojo.roboFont import CurrentFont

# Add paths to libs in sibling repositories
PATHS = ('../TYPETR-Assistants/',)
for path in PATHS:
    if not path in sys.path:
        print('@@@ Append to sys.path', path)
        sys.path.append(path)

from assistantLib.assistantParts.baseAssistantPart import BaseAssistantPart
from assistantLib.assistantParts.data import * # Import anchors names

class KerningLineGlyphPosition:
    """Element that holds position and name of glyphs in the spacer/kerning line. This makes it easier 
    for mouseover to detect clicks on the line"""
    def __init__(self, glyph, x, y, w, h, k, fillColor):
        self.glyph = glyph # RGlyph object 
        self.name = glyph.name
        self.x = x
        self.y = y
        self.w = w
        self.h = h
        self.k = k # Kerning with previoud glyph
        self.fillColor = fillColor

class AssistantPartSpacer(BaseAssistantPart):
    """The Spacer assistant part handles all margins and widths that can be automated.
    It makes guesses based on the names of glyphs, existing components, values in the MasterData
    and Erik van Blokland's Similarity.
    The assistant part gives feedback about where the automated values came from, so it's easier to debug.
    """

    KERN_LINE_SIZE = 48 # Number of glyphs on kerning line
    KERN_SCALE = 0.12 #0.2 Scaler for glyphs on kerning line

    SPACER_FIXED_WIDTH_MARKER_COLOR = 0.5, 0.5, 0.5, 0.5
    SPACER_FIXED_MARGIN_MARKER_COLOR = 0.8, 0.2, 0.4, 0.7
    SPACER_LABEL_FONT = 'Verdana'
    SPACER_LABEL_SIZE = 14
    SPACER_MARKER_R = 32 # Radius of space marker

    SPACER_FILL_COLOR = 0.2, 0.2, 0.2, 1 # Default color
    SPACER_SELECTED_COLOR = 0.2, 0.2, 0.5, 1 # Current glyph
    SPACER_HOVER_COLOR = 1, 0, 0, 1 # Mouse goes over the element
    SPACER_LINE_BOX_COLOR = 0, 0, 0, 0.5 # Stroke color of space box

    def initMerzSpacer(self, container):
        """Define the Merz elements for feedback about where margins/width comes from."""

        #    K E R N I N G  L I N E
    
        self.spacerSampleIndex =  0 # Offset into the full sample, generated by KerningManager for a certain mode
        self.spacerGlyphPositions = [] # Tuples (x, y, w, h, k, glyphName) Adjusted by the line lenght, to center on current glyph.width/2
        self.selectedHoverGlyphName = None # Name of glyph that is currently hovered over in the spacing line.

        self.kerningLine = [] # List of kerned/spaced glyph image layers, also buttons
        self.kerningLineValues = [] # List of kerning value layers
        self.kerningLineNames = [] # List of glyph name layers
        self.kerningLineBoxes = [] # List of kerned glyph em-boxes
        self.kerningSelectedGlyph = None # Name of the glyph selected by the kerning editor

        # White rectangle as background of spacer/kerning line
        self.spacerWhiteBackground = container.appendRectangleSublayer(name="spacesWhiteBackground",
            position=(0, 0),
            size=(1, 1),
            fillColor=(1, 1, 1, 0.6), # Slightly transparant, so rest of EditorWindow can be seen through.
            visible=False,
        )
        self.spacerWhiteBackground.addScaleTransformation(self.KERN_SCALE)
        
        # Glyphs cells on the spacer/kerning line

        for gIndex in range(self.KERN_LINE_SIZE):
            # Previewing current glyphs on left/right side.        
            im = container.appendPathSublayer(
                name=f'kernedGlyph-{gIndex}',
                position=(0, 0),
                fillColor=self.SPACER_FILL_COLOR,
                visible=False,
            )
            im.addScaleTransformation(self.KERN_SCALE)
            self.kerningLine.append(im)
            
            kerningLineValue = container.appendTextLineSublayer(
                name=f'kernedValue-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Can be red (negative kerning) or green (positive kerning)
                visible=False,
            )
            kerningLineValue.addScaleTransformation(self.KERN_SCALE)
            kerningLineValue.setHorizontalAlignment('center')
            self.kerningLineValues.append(kerningLineValue)

            kerningLineBox = container.appendRectangleSublayer(
                name=f'kernedBox-{gIndex}',
                position=(0, 0),
                size=(1, 1),
                fillColor=None,
                strokeColor=self.SPACER_LINE_BOX_COLOR,
                strokeWidth=1,
                visible=False,
            )
            kerningLineBox.addScaleTransformation(self.KERN_SCALE)
            self.kerningLineBoxes.append(kerningLineBox)

            kerningLineName = container.appendTextLineSublayer(
                name=f'kernedName-{gIndex}',
                position=(0, 0),
                text='xxx\nxxx',
                font=self.SPACER_LABEL_FONT,
                pointSize=self.SPACER_LABEL_SIZE,
                fillColor=self.SPACER_FILL_COLOR, # Default line glyph color
                visible=False,
            )
            kerningLineName.addScaleTransformation(self.KERN_SCALE)
            kerningLineName.setHorizontalAlignment('center')
            self.kerningLineNames.append(kerningLineName)

        self.kerningSelectedGlyphMarker = container.appendRectangleSublayer(
            name='kerningSelectedGlyphMarker',
            position=(0, 0),
            size=(1, 20),
            fillColor=(1, 0, 0, 1),
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.kerningSelectedGlyphMarker.addScaleTransformation(self.KERN_SCALE)

        self.kerning1Value = container.appendTextLineSublayer(
            name="kerning1Value",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning1Value.setHorizontalAlignment('center')
        self.kerning2Value = container.appendTextLineSublayer(
            name="kerning2Value",
            position=(0, 0),
            text='xxx\nxxx',
            font='Courier',
            pointSize=32,
            fillColor=(1, 0, 0, 1),
            visible=False,
        )
        self.kerning2Value.setHorizontalAlignment('center')

        self.kerningCursorBox = container.appendTextLineSublayer(
            name="kerningCursorBox",
            position=(0, 0),
            text='xxx\nxxx',
            font=self.SPACER_LABEL_FONT,
            pointSize=14,
            fillColor=(0.6, 0.6, 0.6, 1),
            visible=False,
        )


        #   S P A C I N G  M A R K E R S

        self.fixedSpaceMarkerLeft = container.appendOvalSublayer(name="spaceMarkerLeft",
            position=(-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
        )
        self.leftSpaceSourceLabel = container.appendTextLineSublayer(name="leftSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.leftSpaceSourceLabel.setHorizontalAlignment('right')
        
        self.fixedSpaceMarkerRight = container.appendOvalSublayer(name="spaceMarkerRight",
            position=(1000-self.SPACER_MARKER_R, -self.SPACER_MARKER_R),
            size=(self.SPACER_MARKER_R*2, self.SPACER_MARKER_R*2),
            fillColor=None,
            strokeColor=None,
            strokeWidth=1,
            visible=False,
        )
        self.rightSpaceSourceLabel = container.appendTextLineSublayer(name="rightSpaceSourceLabel",
            position=(0, -self.SPACER_MARKER_R*2),
            text=' '*40,
            font='Verdana',
            pointSize=self.SPACER_LABEL_SIZE,
            fillColor=(0, 0, 0, 1),
            visible=False,
        )
        self.rightSpaceSourceLabel.setHorizontalAlignment('left')

    def updateMerzSpacer(self, info):
        """Update the spacing/kerning sample line"""
        c = self.getController()
        g = info['glyph']
        if g is None:
            return 
        if c.w.showSpacingSampleLine.get():
            self.updateMerzSpacerKerningLine(g)
        else:
            self.hideMerzSpacerKerningLine()
            g.changed()

    def hideMerzSpacerKerningLine(self):
        for kerningGlyphLayer in self.kerningLine:
            kerningGlyphLayer.setVisible(False)
        for kerningNameLayer in self.kerningLineNames:
            kerningNameLayer.setVisible(False)
        self.spacerWhiteBackground.setVisible(False)

    def updateMerzSpacerKerningLine(self, g):
        """Update the spacing/kerning/sample line for the current glyphs and its settings."""
        c = self.getController()
        f = g.font

        h = f.info.unitsPerEm
        m = h/5 # Margin around white rectangle.
        x = 0 # Adjusted from the previous line calculation
        y = f.info.descender/self.KERN_SCALE - 1.5*m/self.KERN_SCALE
        k = 0 # TODO For now, later we'll add kerning here.
        dw = f.info.unitsPerEm/5 # Extra width to zero-width glyphs

        visible = c.w.showSpacingSampleLine.get()

        km = self.getKerningManager(g.font)

        # Testing the KernNet in kerningManager
        #g1Name = c.w.previewGlyphLeftName.get() or 'H'
        #if g1Name in f:
        #    k = km.getKernNetKerning(f[g1Name], g, step=None)
        #    print(f'...KernNet {g1Name} {g.name} {k}')

        sampleContext = c.w.spacerMode.get()
        # 0    Glyphset
        # 1    According to similarity
        # 2    By group mode context
        # 3    By spacing mode context
        # 4    By kerning mode context
        # Get a spacing sample for the right amount of glyphs for the selected context
        sample = km.getSpacingSample(g, context=sampleContext, length=len(self.kerningLine), index=self.spacerSampleIndex) 

        self.spacerGlyphPositions = [] # Reset the list of KerningLineGlyphPosition instances.

        # We need to do this in 2 runs unfortunately, constructing the list of spacerGlyphPositions first,
        # in order to center the line by its total width.
        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine): # List of kerned glyph images
            if gIndex >= len(sample):
                break
            spaceG = f[sample[gIndex]]
            if g.name == spaceG.name:
                color = self.SPACER_SELECTED_COLOR
            else:
                color = self.SPACER_FILL_COLOR
            sw = spaceG.width
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw
                sw += dw
            self.spacerGlyphPositions.append(KerningLineGlyphPosition(spaceG, x, y, sw, h, k, color))
            x += sw + k # @@@ TODO Define kerning k later
            if not sw: # In case of diacritics on width == 0, add wordspace in front and behind.
                x += dw

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + y * tan(radians(-f.info.italicAngle or 0))

        self.spacerWhiteBackground.setPosition((gpFirst.x + offsetX - 2*m, y + f.info.descender - m))
        self.spacerWhiteBackground.setSize((gpLast.x - gpFirst.x + gpLast.w + 4*m, h + 2*m))
        self.spacerWhiteBackground.setVisible(True)

        for gIndex, kerningGlyphLayer in enumerate(self.kerningLine):
            if gIndex >= len(self.spacerGlyphPositions):
                break
            gp = self.spacerGlyphPositions[gIndex]
            
            if self.mouseMovePoint is not None and gp.x <= self.mouseMovePoint.x/self.KERN_SCALE <= gp.x + gp.y:
                color = self.SPACER_HOVER_COLOR
            else:
                color = gp.fillColor 
            kerningGlyphLayer.setFillColor(color)
            kerningGlyphLayer.setPath(gp.glyph.getRepresentation("merz.CGPath"))
            kerningGlyphLayer.setPosition((gp.x + offsetX, y))
            kerningGlyphLayer.setVisible(visible)

            kerningNameLayer = self.kerningLineNames[gIndex]
            kerningNameLayer.setFillColor(color)
            kerningNameLayer.setText(gp.glyph.name)
            kerningNameLayer.setPosition((gp.x + offsetX + gp.w/2, y + f.info.descender))
            kerningNameLayer.setVisible(False) # Will be shown on mouse over hover

        for n in range(gIndex, len(self.kerningLine)):
            self.kerningLine[n].setVisible(False)
            self.kerningLineNames[n].setVisible(False)

    def mouseMoveSpacer(self, g, x, y, event):
        """Set the hoover color for the current selected glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        sy = y/self.KERN_SCALE
        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 + sy * tan(radians(-g.font.info.italicAngle or 0))
        sx = x/self.KERN_SCALE - offsetX

        self.selectedHoverGlyphName = None

        for gIndex, gp in enumerate(self.spacerGlyphPositions):
            #print(gp.x, sx, gp.x + gp.w)
            if gp.x <= sx <= gp.x + gp.w and gp.y - gp.h <= sy <= gp.y + gp.h:
                color = self.SPACER_HOVER_COLOR
                visible = True
                self.selectedHoverGlyphName = gp.name # Used to open the glyph if clicked on.

            elif gp.name == g.name:
                color = self.SPACER_SELECTED_COLOR
                visible = False
            
            else:
                color = self.SPACER_FILL_COLOR
                visible = False
                    
            self.kerningLineNames[gIndex].setFillColor(color)
            self.kerningLine[gIndex].setFillColor(color)
            self.kerningLineNames[gIndex].setVisible(visible)
                    
    def mouseDownSpacer(self, g, x, y, evnt):
        """Open Editor window on clicked glyph"""
        if g is None or not self.spacerGlyphPositions or self.mouseMovePoint is None:
            return

        gpFirst = self.spacerGlyphPositions[0]
        gpLast = self.spacerGlyphPositions[-1]

        sy = y/self.KERN_SCALE
        offsetX = g.width/2/self.KERN_SCALE - (gpLast.x - gpFirst.x)/2 - sy * tan(radians(-g.font.info.italicAngle or 0))
        sx = x/self.KERN_SCALE - offsetX

        if self.selectedHoverGlyphName is not None: # Is there a current hover selected
            OpenGlyphWindow(glyph=g.font[self.selectedHoverGlyphName], newWindow=False)

    def updateSpacer(self, info):
        """If the checkbox is set, then try to check and fix automated margins and width.
        Answer the boolean flag if something was changed to the glyph."""
        g = info['glyph']
        if g is None:
            return changed # Nothing changed.
        changed = self.checkFixGlyphSpacing(g)
        return changed

    def checkFixGlyphSpacing(self, g, updateMerz=True):
        changed = self.checkFixGlyphLeftMargin(g, updateMerz=updateMerz)
        changed |= self.checkFixGlyphRightMargin(g, updateMerz=updateMerz)
        #changed |= self.checkFixGlyphWidth(g)        
        return changed

    KEY_CENTER_GLYPH = '='
    KEY_INC_RIGHT_MARGIN_CAP = 'P'
    KEY_INC_RIGHT_MARGIN = 'p'
    KEY_DEC_RIGHT_MARGIN_CAP = 'O'
    KEY_DEC_RIGHT_MARGIN = 'o'
    KEY_INC_LEFT_MARGIN_CAP = 'I'
    KEY_INC_LEFT_MARGIN = 'i'
    KEY_DEC_LEFT_MARGIN_CAP = 'U'
    KEY_DEC_LEFT_MARGIN = 'u'

    KEY_INC_KERN2_CAP = '>'
    KEY_INC_KERN2 = '.'
    KEY_DEC_KERN2_CAP = '<'
    KEY_DEC_KERN2 = ','
    KEY_INC_KERN1_CAP = 'M'
    KEY_INC_KERN1 = 'm'
    KEY_DEC_KERN1_CAP = 'N'
    KEY_DEC_KERN1 = 'n'

    def buildSpacer(self, y):
        """Build the assistant UI for anchor controls."""
        personalKey_eq = self.registerKeyStroke(self.KEY_CENTER_GLYPH, 'spacerCenterGlyph')

        personalKey_U = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN_CAP, 'spacerDecLeftMarginCap')
        personalKey_u = self.registerKeyStroke(self.KEY_DEC_LEFT_MARGIN, 'spacerDecLeftMargin')
        personalKey_I = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN_CAP, 'spacerIncLeftMarginCap')
        personalKey_i = self.registerKeyStroke(self.KEY_INC_LEFT_MARGIN, 'spacerIncLeftMargin')

        personalKey_O = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN_CAP, 'spacerDecRightMarginCap')
        personalKey_o = self.registerKeyStroke(self.KEY_DEC_RIGHT_MARGIN, 'spacerDecRightMargin')
        personalKey_P = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN_CAP, 'spacerIncRightMarginCap')
        personalKey_p = self.registerKeyStroke(self.KEY_INC_RIGHT_MARGIN, 'spacerIncRightMargin')

        personalKey_larger = self.registerKeyStroke(self.KEY_INC_KERN2_CAP, 'spacerDecKern2Cap')
        personalKey_period = self.registerKeyStroke(self.KEY_INC_KERN2, 'spacerDecKern2')
        personalKey_smaller = self.registerKeyStroke(self.KEY_DEC_KERN2_CAP, 'spacerIncKern2Cap')
        personalKey_comma = self.registerKeyStroke(self.KEY_DEC_KERN2, 'spacerIncKern2')

        personalKey_M = self.registerKeyStroke(self.KEY_INC_KERN1_CAP, 'spacerDecKern1Cap')
        personalKey_m = self.registerKeyStroke(self.KEY_INC_KERN1, 'spacerDecKern1')
        personalKey_N = self.registerKeyStroke(self.KEY_DEC_KERN1_CAP, 'spacerIncKern1Cap')
        personalKey_n = self.registerKeyStroke(self.KEY_DEC_KERN1, 'spacerIncKern1')

        personalKey_pageUp = self.registerKeyStroke(self.PAGE_UP_FUNCTION_KEY, 'spacerPageUp')
        personalKey_pageDown = self.registerKeyStroke(self.PAGE_DOWN_FUNCTION_KEY, 'spacerPageDown')
        personalKey_pageHome = self.registerKeyStroke(self.PAGE_HOME_FUNCTION_KEY, 'spacerPageHome')
        personalKey_pageEnd = self.registerKeyStroke(self.PAGE_END_FUNCTION_KEY, 'spacerPageEnd')

        c = self.getController()
        C0, C1, C2, CW, L = self.C0, self.C1, self.C2, self.CW, self.L
        LL = 18
        c.w.autoSpace = CheckBox((C1, y, CW, L), 'Auto space', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.centerGlyphButton = Button((C2, y, CW, L), f'Center width [{personalKey_eq}]', callback=self.spacerCenterGlyphCallback)
        y += L
        c.w.splitSimScripts = CheckBox((C0, y, CW, L), 'Split Sim scripts', value=True, sizeStyle='small', callback=self.updateEditor)
        c.w.showSpacingSampleLine = CheckBox((C1, y, CW, L), 'Show sample line', value=True, sizeStyle='small', callback=self.updateEditor)
        
        c.w.decLeftMarginButton = Button((C2, y, CW/4, L), f'<[{personalKey_u}]', callback=self.spacerDecLeftMarginCallback)
        c.w.incLeftMarginButton = Button((C2+CW/4, y, CW/4, L), f'[{personalKey_i}]>', callback=self.spacerIncLeftMarginCallback)
        c.w.decRightMarginButton = Button((C2+2*CW/4, y, CW/4, L), f'<[{personalKey_o}]', callback=self.spacerDecRightMarginCallback)
        c.w.incRightMarginButton = Button((C2+3*CW/4, y, CW/4, L), f'[{personalKey_p}]>', callback=self.spacerIncRightMarginCallback)
        y += L
        c.w.spacerMode = RadioGroup((C0, y, 2*CW, L), ('Glyphs', 'Similar', 'Group', 'Space', 'Kern'), isVertical=False, sizeStyle='small', callback=self.updateEditor)
        c.w.spacerMode.set(1)
        c.w.kerningSamplePattern1 = EditText((C2, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 1
        c.w.kerningSampleValue = EditText((C2+CW/2-18, y, 36, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning value range sample group 1
        c.w.kerningSamplePattern2 = EditText((C2+CW/2+18, y, CW/2-18, L), callback=self.makeKerningSampleCallback) # Pattern for selecting kerning sample group 2
        #c.w.decKern2Button = Button((C2, y, CW/4, L), '<[%s]' % personalKey_m, callback=self.spacerDecKern2Callback)
        #c.w.incKern2Button = Button((C2+CW/4, y, CW/4, L), '[%s]>' % personalKey_n, callback=self.spacerIncKern2Callback)
        #c.w.decKern1Button = Button((C2+2*CW/4, y, CW/4, L), '<[%s]' % personalKey_period, callback=self.spacerDecKern1Callback)
        #c.w.incKern1Button = Button((C2+3*CW/4, y, CW/4, L), '[%s]>' % personalKey_comma, callback=self.spacerIncKern1Callback)
        y += L
        c.w.autoSpaceAllButton = Button((C0, y, CW, L), 'Auto space all', callback=self.autoSpaceAllCallback)
        c.w.fixReportedSpacingDifferences = CheckBox((C1, y, CW, L), 'Fix reported', value=False, sizeStyle='small')
        c.w.reportSpacingButton = Button((C2, y, CW, L), 'Report spacing', callback=self.reportSpacingCallback)
        y += L + 10
        c.w.factorKernNetTextBox = EditText((C0, y, 48, L))
        c.w.factorKernNetTextBox.set('1.2')
        c.w.calibrateKernNetTextBox = EditText((C1, y, 48, L))
        c.w.calibrateKernNetTextBox.set('0')
        c.w.autoKernAllGroupsButton = Button((C2, y, CW, L), 'Auto kern groups', callback=self.autoKernGroupsCallback)
        y += L + 10
        c.w.spacerEndLine = HorizontalLine((self.M, y, -self.M, 1))
        c.w.spacerEndLine2 = HorizontalLine((self.M, y, -self.M, 1))
        y += L/5

        return y

    def makeKerningSampleCallback(self, sender):
        """One of the kerning sample filters changed, let de kerning manager make a new kerning sample."""
        c = self.getController()
        g = self.getCurrentGlyph()
        km = self.getKerningManager(g.font)
        km.kerningSamplePattern1 = c.w.kerningSamplePattern1.get() or None
        km.kerningSampleValue = int(c.w.kerningSampleValue.get() or 0) or None
        km.kerningSamplePattern2 = c.w.kerningSamplePattern2.get() or None
        g.changed()
        
    def autoSpaceAllCallback(self, sender):
        """Auto space all UFO's in the family, recursively applying all rules until that base glyph. Keep track of the glyphs 
        that were modified to avoid double work. Report on the glypns that got changed."""
        print('--- Auto spacing all masters')
        f = self.getCurrentFont()
        parentPath = self.filePath2ParentPath(f.path)

        for pth in self.getUfoPaths(parentPath):
            f = self.getFont(pth)
            print(f'... Auto spacing {f.path.split("/")[-1]}')
            for g in f: # First check all glyphs without components
                if g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            for g in f: # Then check all glyphs with components
                if not g.components:
                    continue
                changed = self.checkFixGlyphSpacing(g, updateMerz=False)
                if changed:
                    g.changed()
            # Watch out: this will auto-save the adjusted font
            f.save()

    def autoKernGroupsCallback(self, sender):
        """Auto kern all groups and kerning pairs for the given template for all UFO's in the family.
        Report on the groups and pairs that got changed. Only perform real changes if the safety switch is enabled."""
        print('--- Auto kern all masters')
        f = self.getCurrentFont()
        km = self.getKerningManager(f)
        try:
            factor = float(self.w.factorKernNetTextBox.get())
        except ValueError:
            factor = 1
        try:
            calibrate = int(self.w.calibrateKernNetTextBox.get())
        except ValueError:
            calibrate = 0
        km.kernGroups(factor=factor, calibrate=calibrate, verbose=True)

    def reportSpacingCallback(self, sender):
        """Report/fix margins for the current font that don't fit the epexted value as it would have been auto spaced.
        This method both allowed to get feedback on how accurate the autospacer works. And it gives a list of glyphs
        that need extra attention."""
        f = self.getCurrentFont()
        changed = self.reportSpacing(self, f)
        if changed:
            f.changed()

    def reportSpacing(self, f, doFix=False):
        changed = False
        c = self.getController()
        md = self.getMasterData(f)
        km = self.getKerningManager(f)

        # First check all glyphs without component
        for g in f:
            if g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        # Then check all glyphs with components
        for g in f:
            if not g.components:
                continue

            if not g.name in md.glyphSet.glyphs:
                print(f'### Missing glyph /{g.name} in glypset-->glyphData.')
                continue

            gd = md.glyphSet.get(g.name)

            if doFix or c.w.fixReportedSpacingDifferences.get():
                changed |= km.fixLeftMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
                changed |= km.fixRightMarginByGlyphSetReference(g) # See if there is anything to fix, then do it and answer if something changed.     
            
            else: # Just report if there is anything to do
                lm = km.getLeftMarginByGlyphSetReference(g)
                alm = g.angledLeftMargin
                if alm is not None and lm is not None and not self._equalGlyphLeftMargin(g, lm):
                    print(f'... Diff {int(round(alm - lm))} in left margin {alm} for /{g.name} and expected auto space {lm}')

                rm = km.getRightMarginByGlyphSetReference(g)
                arm = g.angledRightMargin
                if arm is not None and rm is not None and not self._equalGlyphRightMargin(g, rm):
                    print(f'... Diff {int(round(arm - lm))} in right margin {arm} for /{g.name} and expected auto space {rm}')

        return changed

    def spacerDecLeftMarginCallback(self, sender):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncLeftMarginCallback(self, sender):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecRightMarginCallback(self, sender):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncRightMarginCallback(self, sender):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()


    def spacerDecLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -5)
        g.changed()

    def spacerDecLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncLeftMarginCap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 5)
        g.changed()

    def spacerIncLeftMargin(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, -5)
        g.changed()

    def spacerDecRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncRightMarginCap(self, g, c, event):
        self._adjustRightMarginByUnits(g, 5)
        g.changed()

    def spacerIncRightMargin(self, g, c, event):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()

    #   K E R N I N G  K E Y S

    def spacerDecKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern2Callback(self, sender):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern1Callback(self, sender):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()


    def spacerDecKern2Cap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -5)
        g.changed()

    def spacerDecKern2(self, g, c, event):
        self._adjustLeftMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern2Cap(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 5)
        g.changed()

    def spacerIncKern2(self, g, c, event):
        self._adjustLeftMarginByUnits(g, 1)
        g.changed()

    def spacerDecKern1Cap(self, g, c, event):
        self._adjustRightMarginByUnits(g, -5)
        g.changed()

    def spacerDecKern1(self, g, c, event):
        self._adjustRightMarginByUnits(g, -1)
        g.changed()

    def spacerIncKern1Cap(self, g, c, event):
        self._adjustRightMarginByUnits(g, 5)
        g.changed()

    def spacerIncKern1(self, g, c, event):
        self._adjustRightMarginByUnits(g, 1)
        g.changed()
    
    #   S A M P L E  K E Y S

    def spacerPageUp(self, g, c, event):
        if event['shiftDown']:
            dec = len(self.kerningLine)
        else:
            dec = 1
        self.spacerSampleIndex = max(0, self.spacerSampleIndex - dec)
        print(self.spacerSampleIndex)
        g.changed()
        #print('Page Up', event['shiftDown'], event['optionDown'], event['controlDown'], event['commandDown'])

    def spacerPageDown(self, g, c, event):
        if event['shiftDown']:
            inc = len(self.kerningLine)
        else:
            inc = 1
        self.spacerSampleIndex += inc
        print(self.spacerSampleIndex)
        g.changed()
        #print('Page Down', event['shiftDown'], event['optionDown'], event['controlDown'], event['commandDown'])

    def spacerPageHome(self, g, c, event):
        self.spacerSampleIndex = 0
        g.changed()
        #print('Page Home', event['shiftDown'], event['optionDown'], event['controlDown'], event['commandDown'])

    def spacerPageEnd(self, g, c, event):
        self.spacerSampleIndex = 1000
        g.changed()
        #print('Page End', event['shiftDown'], event['optionDown'], event['controlDown'], event['commandDown'])

    #   A D J U S T  S P A C I N G

    SPACING_UNIT = 4

    def _adjustLeftMarginByUnits(self, g, value): 
        if self.isUpdating:
            return
        f = g.font        
        g.angledLeftMargin = int(round(g.angledLeftMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT
                          
    def _adjustRightMarginByUnits(self, g, value): # This moved to TYPETR-Assistants/KerningAssistant-005.py
        if self.isUpdating:
            return
        f = g.font
        g.angledRightMargin = int(round(g.angledRightMargin/self.SPACING_UNIT) + value) * self.SPACING_UNIT

    """
        #    K E R N I N G

        elif characters in '.>': # Increment right kerning
            if shiftDown:
                self._adjustRightKerning(g, 5) # 20
            else:
                self._adjustRightKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in ',<': # Decrement right kerning
            if shiftDown:
                self._adjustRightKerning(g, -5) # 20
            else:
                self._adjustRightKerning(g, -1) # 4
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Mm': # Decrement left kerning
            if shiftDown:
                self._adjustLeftKerning(g, -5) # 20
            else:
                self._adjustLeftKerning(g, -1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        
        elif characters in 'Nn': # Increment left kerning
            if shiftDown:
                self._adjustLeftKerning(g, 5) # 20
            else:
                self._adjustLeftKerning(g, 1) # 4           
            changed |= self.checkSpacingDependencies(g) # Update the spacing consistency for all glyphs in the kerning line
        """

    #   G U E S S  S P A C I N G  &  K E R N I N G

    def checkFixGlyphWidth(self, g, km=None):
        """Use the KerningManager for the current font to determine the best width for this glyph.
        Check if this glyph should have its width altered. If it has components, then fix those first.
        If something changed, then answer True. 
        """
        changed = False
        if km is None:
            km = self.getKerningManager(g.font)

        label = ''
        color = 0, 0, 0, 0
    
        width = km.getWidth(g)
        if width is not None:
            changed = self._fixGlyphWidth(g, width)
            label = f'Width={g.width}' 
            color = self.SPACER_FIXED_WIDTH_MARKER_COLOR

        self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
        self.fixedSpaceMarkerRight.setFillColor(color)
        self.fixedSpaceMarkerRight.setVisible(True)

        self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*4))
        self.rightSpaceSourceLabel.setText(label)
        self.rightSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphLeftMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best left margin for this glyph.
        Check if this glyph should have its left margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        if c is None: # The window may have been closed
            return False # Nothing happened

        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        if c.w.autoSpace.get():

            md = self.getMasterData(g.font)
            gd = md.glyphSet[g.name]
            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphLeftMargin: Cannot find GlyphData for /{g.name}')
            
            elif 'off' in (gd.l, gd.r):
                label = f'Auto-spacing is off'
                print(f'... checkFixGlyphLeftMargin: /{g.name} auto-spacing is off')

            # First check if there is a masterData spacing source defined, that overwrites all other spacing rules
            elif md.spacingSrcUFOPath is not None and g.width:  # Only if defined and the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    lm = src[g.name].angledLeftMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledLeftMargin))}+{md.spacingOffset}={int(round(lm))}'
                    changed = km.fixLeftMargin(g, lm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.leftMargin is None: # Empty glyph, can't set left/right margin
                pass

            else: # Otherwise 
                referenceLabel = gd.leftSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixLeftMarginByGlyphSetReference(g) # Fix the left margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledLeftMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else: # Strategy #2, see if there is a similar glyph to copy the left margin from.
                    similarName2 = km.getSimilarBaseName2(g)
                    if similarName2 is not None:
                        srcG2 = g.font[similarName2]
                        if similarName2 == g.name:
                            label = f'Sim base /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG2.name} {int(round(srcG2.angledLeftMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixLeftMargin(g, srcG2.angledLeftMargin, label)
                    else:
                        label = f'{int(round(g.angledLeftMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledLeftMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5

        if updateMerz:
            self.fixedSpaceMarkerLeft.setPosition((-self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerLeft.setFillColor(fillColor)
            self.fixedSpaceMarkerLeft.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerLeft.setVisible(True)

            self.leftSpaceSourceLabel.setPosition((0, -self.SPACER_MARKER_R*2))
            self.leftSpaceSourceLabel.setText(label)
            self.leftSpaceSourceLabel.setVisible(True)

        return changed

    def checkFixGlyphRightMargin(self, g, km=None, updateMerz=True):
        """Use the KerningManager for the current font to determine the best right margin for this glyph. 
        Check if this glyph should have its right margin altered. If it has components, then fix those first.
        If something changed, then answer True. 

        @@@ updateMerz is a bit of a hack, to make this method callable for controllers. The fixing and Merz should be split in the future.
        """
        c = self.getController()
        changed = False
        fillColor = 0, 0, 0, 0.2
        strokeColor = 0, 0, 0, 0

        if c is None: # Window may have been closed already
            return changed

        if c.w.autoSpace.get():

            md = self.getMasterData(g.font)
            gd = md.glyphSet[g.name]
            if km is None:
                km = self.getKerningManager(g.font)

            label = ''

            if gd is None: # Cannot find this glyph
                print(f'### checkFixGlyphRightMargin: Cannot find GlyphData for /{g.name}')

            elif 'off' in (gd.l, gd.r):
                label = f'Auto-spacing is off'
                print(f'... checkFixGlyphRightMargin: /{g.name} auto-spacing is off')

            elif md.spacingSrcUFOPath is not None and g.width: # Only if defined and if the glyph has width
                src = self.getFont(md.spacingSrcUFOPath)
                if g.name in src:
                    rm = src[g.name].angledRightMargin + md.spacingOffset
                    label = f'Src {self.path2UfoName(md.spacingSrcUFOPath)} {int(round(src[g.name].angledRightMargin))}+{md.spacingOffset}={int(round(rm))}'
                    changed = km.fixRightMargin(g, rm, label)
                else:
                    print(f'### Glyph /{g.name} does not exist in spacing ref {md.spacingSrcUFOPath}')

            elif g.rightMargin is None: # Empty glyph, can't set left/right margin
                pass

            else:
                referenceLabel = gd.rightSpaceSourceLabel # Test the existence of a reference label to know if there is one.
                if referenceLabel: # Strategy #1, check with the referenced left margin
                    changed |= km.fixRightMarginByGlyphSetReference(g) # Fix the right margin if different to what the reference has.
                    label = f'Ref {referenceLabel} {int(round(g.angledRightMargin))}' # Show the fixed value in the label
                    fillColor = 0, 1, 0, 0.5
                    strokeColor = None
                else:
                    similarName1 = km.getSimilarBaseName1(g)
                    if similarName1 is not None:
                        srcG1 = g.font[similarName1]
                        if similarName1 == g.name:
                            label = f'Sim base /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = None
                            strokeColor = 0, 0, 0, 0.5
                        else:
                            label = f'Sim /{srcG1.name} {int(round(srcG1.angledRightMargin))}'
                            fillColor = 1, 0, 0, 0.5
                            strokeColor = None
                        changed |= km.fixRightMargin(g, srcG1.angledRightMargin, label)
                    else:
                        label = f'{int(round(g.angledRightMargin))}' # No reference or similarity. This margin can be changed. Just show the value
                        fillColor = None
                        strokeColor = 0, 0, 0, 0.5

        else:
            label = str(int(round(g.angledRightMargin)))
            fillColor = None
            strokeColor = 0, 0, 0, 0.5
        label += f'\n(w={g.width})'

        if updateMerz:
            self.fixedSpaceMarkerRight.setPosition((g.width - self.SPACER_MARKER_R, -self.SPACER_MARKER_R))
            self.fixedSpaceMarkerRight.setFillColor(fillColor)
            self.fixedSpaceMarkerRight.setStrokeColor(strokeColor)
            self.fixedSpaceMarkerRight.setVisible(True)
            
            self.rightSpaceSourceLabel.setPosition((g.width, -self.SPACER_MARKER_R*2))
            self.rightSpaceSourceLabel.setText(label)
            self.rightSpaceSourceLabel.setVisible(True)

        return changed
    
    def spacerCenterGlyphCallback(self, sender):
        """Callback from button. Center the current glyph on its width, if not done autmatically."""
        g = self.getCurrentGlyph()
        if g is not None:
            if self.spacerCenterGlyph(g):
                g.changed()

    def spacerCenterGlyph(self, g, c, event):     
        """Snap the selected points of the current glyph onto points that are within range on the background glyph."""
        changed = False
        lm = g.angledLeftMargin
        rm = g.angledRightMargin
        w = g.width
        if lm is not None:
            g.angledLeftMargin = (lm + rm)/2
            g.width = w
            changed = True

        return changed
