# PLEASE NOTE: This was generously given to me by Tal Leming.
# This for use WITHIN Type Network only. Please do not publicize or distribute.

from ufo2fdk.kernFeatureWriter import KernFeatureWriter, inlineGroupInstance

# ---------------
# Feature Writers
# ---------------



class BasicFeatureWriter(KernFeatureWriter):

    def write(self, appVersion="0.0", testMode=False):
        import time
        if testMode:
            notes = []
        else:
            notes = [
                "# Class Kerning Data Generated by MetricsMachine %s" % appVersion,
                u"# UFO: %s" % self.font.path,
                "# Date: %s" % time.strftime("%A %B %d, %Y %H:%M:%S"),
                ""
            ]
        notes = u"\n".join(notes)
        return super(BasicFeatureWriter, self).write(notes)

    def getReferencedGroups(self):
        left = {}
        right = {}
        for groupName, glyphList in self.font.groups.items():
            if groupName.startswith("@MMK_L_"):
                left[groupName] = set(glyphList)
            elif groupName.startswith("@MMK_R_"):
                right[groupName] = set(glyphList)
        return left, right

    def getUnreferencedGroups(self):
        return {}, {}

import time

class SubtableBreakWriter(BasicFeatureWriter):

    def write(self, appVersion="0.0", testMode=False):
        font = self.font
        groups = self.font.groups

        if testMode:
            notes = []
        else:
            notes = [
                "# Class Kerning Data Generated by MetricsMachine %s" % appVersion,
                u"# UFO: %s" % self.font.path,
                "# Date: %s" % time.strftime("%A %B %m, %Y %H:%M:%S"),
                ""
            ]
        notes = u"\n".join(notes)

        # break the pairs up by type
        # this will also decompose all special exceptions
        glyphGlyph, glyphGroupDecomposed, groupGlyphDecomposed, glyphGroup, groupGlyph, groupGroup = self.getSeparatedPairs(self.pairs)

        # make lists of all referenced pair members
        allPairs = glyphGlyph.keys() + glyphGroupDecomposed.keys() + \
            groupGlyphDecomposed.keys() + glyphGroup.keys() + \
            groupGlyph.keys() + groupGroup.keys()
        neededGlyphs = set()
        neededGroups = set()
        for left, right in allPairs:
            # break the left and right into a list of all members
            if isinstance(left, inlineGroupInstance):
                pass
            elif left.startswith("@"):
                left = set([left]) | set(groups[left])
            else:
                left = [left]
            if isinstance(right, inlineGroupInstance):
                pass
            elif right.startswith("@"):
                right = set([right]) | set(groups[right])
            else:
                right = [right]
            for i in set(left) | set(right):
                if i.startswith("@"):
                    neededGroups.add(i)
                else:
                    neededGlyphs.add(i)

        # figure out the script for all pair members
        glyphToScript = {}
        groupToScript = {}
        for glyphName in neededGlyphs:
            script = font.unicodeData.scriptForGlyphName(glyphName)
            glyphToScript[glyphName] = script
        for groupName in neededGroups:
            groupToScript[groupName] = set()
            for glyphName in groups[groupName]:
                script = glyphToScript[glyphName]
                groupToScript[groupName].add(script)

        # break groups into script subdivisions
        newGroups, oldGroupNameToNewGroupNames, newGroupNameToOldGroupName = self.getScriptDividedGroups(groupToScript, glyphToScript)

        leftIsGlyphPairs = {}
        scriptSeparatedPairs = {}
        order = [
            ("# glyph, glyph", glyphGlyph),
            ("# glyph, group exceptions", glyphGroupDecomposed),
            ("# group exceptions, glyph", groupGlyphDecomposed),
            ("# glyph, group", glyphGroup),
            ("# group, glyph", groupGlyph),
            ("# group, group", groupGroup),
        ]
        for note, pairs in order:
            for (left, right), value in pairs.items():
                # rename right as needed
                if not isinstance(right, inlineGroupInstance) and right in oldGroupNameToNewGroupNames:
                    right = oldGroupNameToNewGroupNames[right]
                else:
                    right = [right]
                # catch lefts that are not groups
                # XXX these could be separated into script divisions as well.
                if isinstance(left, inlineGroupInstance):
                    if note not in leftIsGlyphPairs:
                        leftIsGlyphPairs[note] = {}
                    for r in right:
                        leftIsGlyphPairs[note][left, r] = value
                    continue
                elif not left.startswith("@"):
                    if note not in leftIsGlyphPairs:
                        leftIsGlyphPairs[note] = {}
                    for r in right:
                        leftIsGlyphPairs[note][left, r] = value
                    continue
                # any left from here on is a group
                if left in oldGroupNameToNewGroupNames:
                    left = oldGroupNameToNewGroupNames[left]
                else:
                    left = [left]
                for l in left:
                    script = groupToScript[l]
                    assert len(script) == 1
                    script = list(script)[0]
                    if script not in scriptSeparatedPairs:
                        scriptSeparatedPairs[script] = {}
                    if note not in scriptSeparatedPairs[script]:
                        scriptSeparatedPairs[script][note] = {}
                    for r in right:
                        scriptSeparatedPairs[script][note][l, r] = value

        # write the classes
        classes = []
        skipped = set()
        for groupName in sorted(neededGroups):
            if groupName in oldGroupNameToNewGroupNames:
                skipped = skipped | set(oldGroupNameToNewGroupNames[groupName])
            elif groupName in newGroupNameToOldGroupName:
                skipped.add(groupName)
            else:
                group = newGroups[groupName]
                l = "%s = [%s];" % (groupName, " ".join(sorted(group)))
                classes.append(l)
        written = set()
        for groupName in sorted(skipped):
            if groupName in written:
                continue
            oldName = newGroupNameToOldGroupName[groupName]
            classes.append("# script subdivisions from %s" % oldName)
            for newName in sorted(oldGroupNameToNewGroupNames[oldName]):
                group = newGroups[newName]
                l = "%s = [%s];" % (newName, " ".join(sorted(group)))
                classes.append(l)
                written.add(newName)

        # write the rules
        order = [tag for tag, l in order]
        rules = []
        for note in order:
            if note not in leftIsGlyphPairs:
                continue
            rules.append("")
            rules.append(note)
            rules += self.getFeatureRulesForPairs(leftIsGlyphPairs[note])
        if leftIsGlyphPairs and scriptSeparatedPairs:
            rules.append("")
            rules.append("subtable;")
        for index, (script, groupedPairs) in enumerate(sorted(scriptSeparatedPairs.items())):
            rules.append("")
            rules.append("# %s" % ("-" * len(script)))
            rules.append("# %s" % script)
            rules.append("# %s" % ("-" * len(script)))
            for note in order:
                if note not in groupedPairs:
                    continue
                rules.append("")
                rules.append(note)
                rules += self.getFeatureRulesForPairs(groupedPairs[note])
            if index < len(scriptSeparatedPairs) - 1:
                rules.append("")
                rules.append("subtable;")

        # compile
        feature = []
        for line in classes + rules:
            if line:
                line = "    " + line
            feature.append(line)
        feature =["feature kern {", notes] + feature + ["} kern;"]
        return "\n".join(feature)

    def getScriptDividedGroups(self, groupToScript, glyphToScript):
        groups = self.font.groups
        newGroups = {}
        oldGroupNameToNewGroupNames = {}
        newGroupNameToOldGroupName = {}
        renameCounter = 0
        for groupName, scriptList in groupToScript.items():
            # only one script. no need to rename.
            if len(scriptList) == 1:
                newGroups[groupName] = set(groups[groupName])
                continue
            renameCounter += 1
            # create the new group names and groups
            if groupName.startswith("@MMK_L_"):
                baseName = "@MMK_L_Split%d_" % renameCounter
            else:
                baseName = "@MMK_R_Split%d_" % renameCounter
            newGroupNames = [baseName + script for script in scriptList]
            oldGroupNameToNewGroupNames[groupName] = newGroupNames
            for newGroupName in newGroupNames:
                newGroups[newGroupName] = set()
            # add the glyphs to the groups
            for glyphName in groups[groupName]:
                script = glyphToScript[glyphName]
                newGroups[baseName + script].add(glyphName)
            # update the group to script map
            del groupToScript[groupName]
            for script in scriptList:
                groupToScript[baseName + script] = [script]
                newGroupNameToOldGroupName[baseName + script] = groupName
        return newGroups, oldGroupNameToNewGroupNames, newGroupNameToOldGroupName

if __name__ == "__main__":
    f = CurrentFont()
    k = SubtableBreakWriter(f.naked())
    f.features.text += k.write()
